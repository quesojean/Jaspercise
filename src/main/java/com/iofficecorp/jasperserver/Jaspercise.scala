package com.iofficecorp.jasperserver

import java.io.InputStream

import com.iofficecorp.jasperserver.pumped._
import com.iofficecorp.jasperserver.pumped.domain._
import com.iofficecorp.jasperserver.pumped.report.{Field, _}
import com.iofficecorp.jasperserver.pumped.report.components.{Column, ColumnGroup, _}

import scala.util.Try
import scala.xml.{Elem, NamespaceBinding, NodeSeq, XML}
import scalaxb._


/**
 * Field properties that should be used as keys to refer to
 * field data that could potentially update an xml resource.
 */
sealed trait FieldProps
object FieldProps {
  case object ID extends FieldProps
  case object LABEL extends FieldProps
  case object DATA_TYPE extends FieldProps
  case object ACTIVE extends FieldProps
}


/**
 * The valid namespaces for marshalling and unmarshalling Jasper's xml resources.
 */
sealed trait JasperNamespace
object JasperNamespace {
  def DOMAIN: NamespaceBinding = scalaxb.toScope(Some("jsdomain") -> defaultScope.getURI("jsdomain"))
  def REPORT: NamespaceBinding = scalaxb.toScope(Some("jr") -> defaultScope.getURI("jr"))
}

/**
 * Trait that lays out a contract for generating any XML nested resource within Jasper.
 * @tparam T any legitimate Jasper class generated by scalaxb. (inside package com.iofficecorp.jasperserver.pumped)
 */
sealed trait Danceable[T] extends Product with Serializable  {
  //self type? to guarantee only works with certain types?
  def ROOT_NODE_LABEL:String
  def scope:NamespaceBinding
  def resourceXML:Elem
  def record[T](rec:DataRecord[T], doUpdate:Option[Boolean] = Some(false)): DataRecord[T]
  def recordList[T](recordList:Seq[DataRecord[T]], doUpdate:Option[Boolean] = Some(false)):Seq[DataRecord[T]]
  def workIt:Option[String]
}


/**
 * Builds a domain's nested xml resource schema.xml.  The DomainBuilder's bound genarated class is SchemaType
 * @param resourceXML Elem object which should be loaded from schema.xml
 * @param tableIds Seq of table id suffixes to find within SchemaType
 * @param fieldProps Map of field property data.
 */
final private case class DomainBuilder(resourceXML: Elem, tableIds:Seq[String], fieldProps: Map[FieldProps, String]) extends Danceable[SchemaType] {
  //look at how we can make this generic for both domain, adhoc, reports
  override val ROOT_NODE_LABEL = "schema"
  override val scope: NamespaceBinding = JasperNamespace.DOMAIN
  val itemId:String = fieldProps(FieldProps.ID)
  val itemLabel:String = fieldProps(FieldProps.LABEL)
  val itemDataType:String = fieldProps(FieldProps.DATA_TYPE)
  val itemActive:Boolean = Try(fieldProps(FieldProps.ACTIVE).toBoolean).getOrElse(false)

  override def workIt: Option[String] = {
    val rootObject: SchemaType = fromXML[SchemaType](resourceXML)
    val rootObjectCopy: SchemaType = rootObject.copy(itemGroups = itemGroups(rootObject))
    if (!rootObject.equals(rootObjectCopy)) {
      val updatedXML: NodeSeq = toXML(rootObjectCopy, None, ROOT_NODE_LABEL, scope)
      Some(updatedXML.toString())
    } else {
      None
    }
  }

  /**
   * Return optional ItemGroupsType object
   * @param schema SchemaType root object
   * @return optional ItemGroupsType object
   */
  def itemGroups(schema: SchemaType): Option[ItemGroupsType] = schema.itemGroups.flatMap {
    case itemGroups: ItemGroupsType => Option(itemGroups
      .copy(itemgroupstypeoption = recordList(itemGroups.itemgroupstypeoption)))
  }

  /**
   * Whether to update this item group.  If the attribute id ends in on of the table identifiers,
   * then we are good to go
   * @param itemGroup ItemGroupType object
   * @return Boolean value whether to update this item group
   */
  def doUpdateItemGroup(itemGroup: ItemGroupType): Boolean = {
    tableIds.exists(tableId => itemGroup.attr_id.endsWith(tableId))
  }

  /**
   * Whether to update this item.  If the resource id of the item ends in itemId, then good to go.
   * @param item ItemType object
   * @return Boolean value whether to update this item
   */
  def doUpdateItem(item: ItemType): Boolean = {
    item.attr_resourceId.endsWith(itemId)
  }

  override def recordList[A](recordList:Seq[DataRecord[A]], doUpdate:Option[Boolean] = Some(false)):
  Seq[DataRecord[A]] = {
    recordList map {
      case itemGroupsTypeOption if itemGroupsTypeOption.key.contains("itemGroup") => record(itemGroupsTypeOption)
      case itemsTypeOption if itemsTypeOption.key.contains("item") => record(itemsTypeOption, doUpdate)
      case record => record
    }
  }

  override def record[A](rec:DataRecord[A], doUpdate:Option[Boolean] = Some(false)): DataRecord[A] =
  {
    val dataRecord = rec.value match {
      case itemGroup:ItemGroupType if doUpdateItemGroup(itemGroup) =>
        DataRecord(rec.namespace, rec.key, itemGroup.copy(items = itemGroup.items.flatMap {
          case items: ItemsType => Option(items
            .copy(itemstypeoption = recordList(items.itemstypeoption, Some(true)))/*updateDataRecordItemTypeableList(items.itemstypeoption)*/)
        }))
      //The extra doUpdate.contains(true) refers to previous recursive call on itemgroup.
      case item: ItemType if doUpdateItem(item) && doUpdate.contains(true) =>
        DataRecord(rec.namespace, rec.key, item.copy(attributes = item.attributes + ("@label" -> DataRecord(itemLabel))))
      case recordVal => rec
    }
    dataRecord.asInstanceOf[DataRecord[A]]
  }
}

/**
 * Builds an adhoc report's nested xml resource.  The ReportBuilder's bound genarated class is JasperReport
 * @param resourceXML Elem object which should be loaded from appropriate nested xml resource.
 * @param tableIds Seq of table id suffixes to find within JasperReport
 * @param fieldProps Map of field property data.
 */
final private case class ReportBuilder(resourceXML: Elem, tableIds:Seq[String], fieldProps: Map[FieldProps, String]) extends Danceable[JasperReport] {
  override val ROOT_NODE_LABEL = "jasperReport"
  override val scope: NamespaceBinding = JasperNamespace.REPORT
  val fieldId = fieldProps(FieldProps.ID)
  val fieldLabel = fieldProps(FieldProps.LABEL)
  val fieldDataType = fieldProps(FieldProps.DATA_TYPE)
  val fieldActive:Boolean = Try(fieldProps(FieldProps.ACTIVE).toBoolean).getOrElse(false)

  override def workIt: Option[String] = {
    val rootObject: JasperReport = fromXML[JasperReport](resourceXML)
    val rootObjectCopy: JasperReport = rootObject.copy(field = fields(rootObject), summary = summary(rootObject))
    if (!rootObject.equals(rootObjectCopy)) {
      val updatedXML: NodeSeq = toXML(rootObjectCopy, None, ROOT_NODE_LABEL, scope)
      Some(updatedXML.toString())
    } else {
      None
    }
  }

  /**
   * Return an updated Seq of Field objects
   * @param report JasperReport
   * @return JasperReport
   */
  def fields(report: JasperReport): Seq[Field] = {
    def doUpdateField(field: Field): Boolean = {
      field.property.exists(prop => prop.attr_name == "resourceId" && prop.attr_value.get
        .endsWith(fieldId))
    }
    report.field map {
      case updatedField if doUpdateField(updatedField)  =>
        updatedField.copy(property = updatedField.property map {
          case propToUpdate: Property if propToUpdate.attr_name == "adhoc.display" =>
            propToUpdate.copy(attributes = propToUpdate.attributes + ("@value" -> DataRecord(fieldLabel)))
          case prop => prop
        } )
      case field => field
    }
  }

  /**
   * Return an updated report Summary
   * (report column headers is the key here)
   * @param report JasperReport
   * @return Summary
   */
  def summary(report: JasperReport): Option[Summary] = {
    report.summary.flatMap {
      case summary => Option(summary.copy(band = summary.band.flatMap {
        case band => Option (band.copy(bandoption = recordList(band.bandoption)))
      }))
    }
  }

  /**
   * Whether the particular column references the field we need to update.
   * @param column Column object.
   * @return whether we should update this Column object.
   */
  def doUpdateColumn(column: Column): Boolean = {
    def fieldExprMatch(textExpr:String): Boolean = {
      val fieldParts = textExpr.stripPrefix("$F{").stripSuffix("}").split("\\.")
      fieldParts.size == 2 && tableIds.exists(fieldParts.head.endsWith(_) && fieldParts.last.equals(fieldId))
    }
    column.detailCell.tablecelloption.exists(record => record.key.contains("textField")
      && record.as[TextField].textFieldExpression.exists(textExpr => textExpr.mixed.exists(record
    => fieldExprMatch(record.as[String]) )))
  }

  /**
   * Constructs a copied sequence of data records with updated data where appropriate
   * @param recordList Seq of DataRecord[A]
   * @param doUpdate Option whether to update a particular record sequence
   * @tparam A any valid generated jasper type
   * @return Seq of DataRecord[A]
   */
  override def recordList[A](recordList:Seq[DataRecord[A]], doUpdate:Option[Boolean] = Some(false)): Seq[DataRecord[A]] = {
    recordList map {
      case bandOption if bandOption.key.contains("componentElement") => record(bandOption)
      case tableOption if tableOption.key.contains("columnGroup") => record(tableOption)
      case columnGroupOption if columnGroupOption.key.contains("column") => record(columnGroupOption)
      case tableCellOption if tableCellOption.key.contains("textField") => record(tableCellOption, doUpdate)
      case record => record
    }
  }

  /**
   * Constructs a copied record with updated data where appropriate
   * @param rec DataRecord[A]
   * @param doUpdate Option whether to update a particular record
   * @tparam A any valid generated jasper type
   * @return DataRecord[A]
   */
  override def record[A](rec:DataRecord[A], doUpdate:Option[Boolean] = Some(false)): DataRecord[A] =  {
    val dataRecord = rec.value match {
      case compElem:ComponentElement => DataRecord(rec.namespace, rec.key,
        compElem.copy(component = record(compElem.component)))

      case table:Table => DataRecord(rec.namespace, rec.key,
        table.copy(tableoption = recordList(table.tableoption)))

      case columnGroup:ColumnGroup => DataRecord(rec.namespace, rec.key,
        columnGroup.copy(columngroupoption = recordList(columnGroup.columngroupoption)))

      case column:Column if doUpdateColumn(column) => DataRecord(rec.namespace, rec.key,
        column.copy(columnHeader = column.columnHeader.flatMap {
          case tableCellToUpdate: TableCell => Option(tableCellToUpdate.copy(tablecelloption =
            recordList(tableCellToUpdate.tablecelloption, Some(true))))
        }))

      case textField:TextField if doUpdate.contains(true) => DataRecord(rec.namespace, rec.key, textField.copy(
        textFieldExpression = textField.textFieldExpression.flatMap {
          case textFieldExpr => Option(textFieldExpr.copy(mixed = textFieldExpr.mixed map {
            case record: DataRecord[Any] => DataRecord("\"" + fieldLabel + "\"")
          }))
        }))

      case recordVal => rec
    }
    dataRecord.asInstanceOf[DataRecord[A]]
  }
}


/**
 * Singleton that if needed, will return updated xml.
 * The factory will instantiate a particular Danceable case class dependant on the XML resourceStream's
 * namespace uri.
 */
object Jaspercise {

  //NOTE if we return the case class, its Product/Serializable type.
  def apply(resourceStream: InputStream, tableIds: Seq[String], fieldProps: Map[FieldProps, String]): Option[String] = {
    val resourceXML: Elem = XML.load(resourceStream)
    val domainNamespaceURI = JasperNamespace.DOMAIN.uri
    val reportNamespaceURI = JasperNamespace.REPORT.uri
    val builder: Option[Danceable[_ >: SchemaType with JasperReport <: Product with Serializable]] =
      resourceXML.namespace match {
      //stable identifier pattern?
      case `domainNamespaceURI` =>
        //domain builder- SchemaType
        //we could do Any or something to make the fromXML call?
        Some(DomainBuilder(resourceXML, tableIds, fieldProps))
      case `reportNamespaceURI` =>
        //adhoc or report builder - jasperReport (studio, custom reports?)
        Some(ReportBuilder(resourceXML, tableIds, fieldProps))
      case _ => None
    }
    if (builder.isDefined) {
      builder.get.workIt
    } else {
      None
    }
  }
}