// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package com.iofficecorp.jasperserver.pumped.report.components

trait PrintOrder

object PrintOrder {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): PrintOrder = value match {
    case "Vertical" => Vertical
    case "Horizontal" => Horizontal

  }
}

case object Vertical extends PrintOrder { override def toString = "Vertical" }
case object Horizontal extends PrintOrder { override def toString = "Horizontal" }


case class ListType(datasetRun: com.iofficecorp.jasperserver.pumped.report.DatasetRun,
  listContents: com.iofficecorp.jasperserver.pumped.report.components.ListContents,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends com.iofficecorp.jasperserver.pumped.report.ComponentType {
  lazy val attr_printOrder = attributes("@printOrder").as[PrintOrder]
  lazy val attr_ignoreWidth = attributes.get("@ignoreWidth") map { _.as[Boolean] }
}

      


case class ListContents(listcontentsoption: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_height = attributes("@height").as[Long]
  lazy val attr_width = attributes.get("@width") map { _.as[Long] }
}

      

trait ListContentsOption

case class CodeExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class ApplicationIdentifierExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait Type

object Type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Type = value match {
    case "2of7" => Number2of7
    case "3of9" => Number3of9
    case "Bookland" => Bookland
    case "Codabar" => CodabarValue
    case "Code128" => Code128
    case "Code128A" => Code128A
    case "Code128B" => Code128B
    case "Code128C" => Code128C
    case "Code39" => Code39Value
    case "Code39 (Extended)" => Code39u40Extendedu41
    case "EAN128" => EAN128Value
    case "EAN13" => EAN13Value
    case "GlobalTradeItemNumber" => GlobalTradeItemNumber
    case "Int2of5" => Int2of5
    case "Monarch" => Monarch
    case "NW7" => NW7
    case "PDF417" => PDF417Value
    case "PostNet" => PostNetValue
    case "RandomWeightUPCA" => RandomWeightUPCA
    case "SCC14ShippingCode" => SCC14ShippingCode
    case "ShipmentIdentificationNumber" => ShipmentIdentificationNumber
    case "SSCC18" => SSCC18
    case "Std2of5" => Std2of5
    case "UCC128" => UCC128
    case "UPCA" => UPCAValue
    case "USD3" => USD3
    case "USD4" => USD4
    case "USPS" => USPS

  }
}

case object Number2of7 extends Type { override def toString = "2of7" }
case object Number3of9 extends Type { override def toString = "3of9" }
case object Bookland extends Type { override def toString = "Bookland" }
case object CodabarValue extends Type { override def toString = "Codabar" }
case object Code128 extends Type { override def toString = "Code128" }
case object Code128A extends Type { override def toString = "Code128A" }
case object Code128B extends Type { override def toString = "Code128B" }
case object Code128C extends Type { override def toString = "Code128C" }
case object Code39Value extends Type { override def toString = "Code39" }
case object Code39u40Extendedu41 extends Type { override def toString = "Code39 (Extended)" }
case object EAN128Value extends Type { override def toString = "EAN128" }
case object EAN13Value extends Type { override def toString = "EAN13" }
case object GlobalTradeItemNumber extends Type { override def toString = "GlobalTradeItemNumber" }
case object Int2of5 extends Type { override def toString = "Int2of5" }
case object Monarch extends Type { override def toString = "Monarch" }
case object NW7 extends Type { override def toString = "NW7" }
case object PDF417Value extends Type { override def toString = "PDF417" }
case object PostNetValue extends Type { override def toString = "PostNet" }
case object RandomWeightUPCA extends Type { override def toString = "RandomWeightUPCA" }
case object SCC14ShippingCode extends Type { override def toString = "SCC14ShippingCode" }
case object ShipmentIdentificationNumber extends Type { override def toString = "ShipmentIdentificationNumber" }
case object SSCC18 extends Type { override def toString = "SSCC18" }
case object Std2of5 extends Type { override def toString = "Std2of5" }
case object UCC128 extends Type { override def toString = "UCC128" }
case object UPCAValue extends Type { override def toString = "UPCA" }
case object USD3 extends Type { override def toString = "USD3" }
case object USD4 extends Type { override def toString = "USD4" }
case object USPS extends Type { override def toString = "USPS" }

trait Rotation

object Rotation {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Rotation = value match {
    case "None" => NoneType
    case "Left" => LeftType
    case "Right" => RightType
    case "UpsideDown" => UpsideDown

  }
}

case object NoneType extends Rotation { override def toString = "None" }
case object LeftType extends Rotation { override def toString = "Left" }
case object RightType extends Rotation { override def toString = "Right" }
case object UpsideDown extends Rotation { override def toString = "UpsideDown" }


case class Barbecue(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression,
  applicationIdentifierExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.ApplicationIdentifierExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends com.iofficecorp.jasperserver.pumped.report.ComponentType {
  lazy val attr_type = attributes("@type").as[Type]
  lazy val attr_drawText = attributes("@drawText").as[Boolean]
  lazy val attr_checksumRequired = attributes("@checksumRequired").as[Boolean]
  lazy val attr_barWidth = attributes.get("@barWidth") map { _.as[Long] }
  lazy val attr_barHeight = attributes.get("@barHeight") map { _.as[Long] }
  lazy val attr_evaluationTime = attributes("@evaluationTime").as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime]
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_rotation = attributes.get("@rotation") map { _.as[Rotation] }
}

      


case class CodeExpression2(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


trait Barcodable extends com.iofficecorp.jasperserver.pumped.report.ComponentType {
  val codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2
  val attr_evaluationTime: Option[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime]
  val attr_evaluationGroup: Option[String]
}


case class Barcode(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcodable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
}

      


case class PatternExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait Orientation

object Orientation {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Orientation = value match {
    case "0" => Number0
    case "90" => Number90
    case "180" => Number180
    case "270" => Number270
    case "up" => Up
    case "left" => LeftTypeValue
    case "down" => Down
    case "right" => RightTypeValue

  }
}

case object Number0 extends Orientation { override def toString = "0" }
case object Number90 extends Orientation { override def toString = "90" }
case object Number180 extends Orientation { override def toString = "180" }
case object Number270 extends Orientation { override def toString = "270" }
case object Up extends Orientation { override def toString = "up" }
case object LeftTypeValue extends Orientation { override def toString = "left" }
case object Down extends Orientation { override def toString = "down" }
case object RightTypeValue extends Orientation { override def toString = "right" }

trait TextPosition

object TextPosition {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TextPosition = value match {
    case "none" => NoneTypeValue
    case "bottom" => Bottom
    case "top" => Top

  }
}

case object NoneTypeValue extends TextPosition { override def toString = "none" }
case object Bottom extends TextPosition { override def toString = "bottom" }
case object Top extends TextPosition { override def toString = "top" }


trait Barcode4jable extends Barcodable {
  val codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2
  val patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression]
  val attr_evaluationTime: Option[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime]
  val attr_evaluationGroup: Option[String]
  val attr_orientation: Option[com.iofficecorp.jasperserver.pumped.report.components.Orientation]
  val attr_moduleWidth: Option[Double]
  val attr_textPosition: Option[com.iofficecorp.jasperserver.pumped.report.components.TextPosition]
  val attr_quietZone: Option[Double]
  val attr_verticalQuietZone: Option[Double]
}


case class Barcode4j(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
}

      

trait ChecksumMode4j

object ChecksumMode4j {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ChecksumMode4j = value match {
    case "auto" => Auto
    case "ignore" => Ignore
    case "add" => Add
    case "check" => Check

  }
}

case object Auto extends ChecksumMode4j { override def toString = "auto" }
case object Ignore extends ChecksumMode4j { override def toString = "ignore" }
case object Add extends ChecksumMode4j { override def toString = "add" }
case object Check extends ChecksumMode4j { override def toString = "check" }


case class Codabar(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_wideFactor = attributes.get("@wideFactor") map { _.as[Double] }
}

      


trait Barcode4JCode128able extends Barcode4jable {
  val codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2
  val patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression]
  val attr_evaluationTime: Option[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime]
  val attr_evaluationGroup: Option[String]
  val attr_orientation: Option[com.iofficecorp.jasperserver.pumped.report.components.Orientation]
  val attr_moduleWidth: Option[Double]
  val attr_textPosition: Option[com.iofficecorp.jasperserver.pumped.report.components.TextPosition]
  val attr_quietZone: Option[Double]
  val attr_verticalQuietZone: Option[Double]
}


case class Barcode4JCode128(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4JCode128able {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
}

      


case class TemplateExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class EAN128(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  templateExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.TemplateExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4JCode128able {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_checksumMode = attributes.get("@checksumMode") map { _.as[ChecksumMode4j] }
}

      

trait Shape

object Shape {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Shape = value match {
    case "force-none" => Forceu45none
    case "force-square" => Forceu45square
    case "force-rectangle" => Forceu45rectangle

  }
}

case object Forceu45none extends Shape { override def toString = "force-none" }
case object Forceu45square extends Shape { override def toString = "force-square" }
case object Forceu45rectangle extends Shape { override def toString = "force-rectangle" }


case class DataMatrix(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_shape = attributes.get("@shape") map { _.as[Shape] }
}

      


case class Code39(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_checksumMode = attributes.get("@checksumMode") map { _.as[ChecksumMode4j] }
  lazy val attr_displayChecksum = attributes.get("@displayChecksum") map { _.as[Boolean] }
  lazy val attr_displayStartStop = attributes.get("@displayStartStop") map { _.as[Boolean] }
  lazy val attr_extendedCharSetEnabled = attributes.get("@extendedCharSetEnabled") map { _.as[Boolean] }
  lazy val attr_intercharGapWidth = attributes.get("@intercharGapWidth") map { _.as[Double] }
  lazy val attr_wideFactor = attributes.get("@wideFactor") map { _.as[Double] }
}

      


case class Interleaved2Of5(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_checksumMode = attributes.get("@checksumMode") map { _.as[ChecksumMode4j] }
  lazy val attr_displayChecksum = attributes.get("@displayChecksum") map { _.as[Boolean] }
  lazy val attr_wideFactor = attributes.get("@wideFactor") map { _.as[Double] }
}

      


case class UPCA(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_checksumMode = attributes.get("@checksumMode") map { _.as[ChecksumMode4j] }
}

      


case class UPCE(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_checksumMode = attributes.get("@checksumMode") map { _.as[ChecksumMode4j] }
}

      


case class EAN13(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_checksumMode = attributes.get("@checksumMode") map { _.as[ChecksumMode4j] }
}

      


case class EAN8(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_checksumMode = attributes.get("@checksumMode") map { _.as[ChecksumMode4j] }
}

      


case class Barcode4JFourState(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_ascenderHeight = attributes.get("@ascenderHeight") map { _.as[Double] }
  lazy val attr_checksumMode = attributes.get("@checksumMode") map { _.as[ChecksumMode4j] }
  lazy val attr_intercharGapWidth = attributes.get("@intercharGapWidth") map { _.as[Double] }
  lazy val attr_trackHeight = attributes.get("@trackHeight") map { _.as[Double] }
}

      

trait BaselinePosition

object BaselinePosition {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): BaselinePosition = value match {
    case "top" => TopValue
    case "bottom" => BottomValue

  }
}

case object TopValue extends BaselinePosition { override def toString = "top" }
case object BottomValue extends BaselinePosition { override def toString = "bottom" }


case class POSTNET(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_shortBarHeight = attributes.get("@shortBarHeight") map { _.as[Double] }
  lazy val attr_baselinePosition = attributes.get("@baselinePosition") map { _.as[BaselinePosition] }
  lazy val attr_checksumMode = attributes.get("@checksumMode") map { _.as[ChecksumMode4j] }
  lazy val attr_displayChecksum = attributes.get("@displayChecksum") map { _.as[Boolean] }
  lazy val attr_intercharGapWidth = attributes.get("@intercharGapWidth") map { _.as[Double] }
}

      


case class PDF417(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  patternExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.PatternExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcode4jable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[Orientation] }
  lazy val attr_moduleWidth = attributes.get("@moduleWidth") map { _.as[Double] }
  lazy val attr_textPosition = attributes.get("@textPosition") map { _.as[TextPosition] }
  lazy val attr_quietZone = attributes.get("@quietZone") map { _.as[Double] }
  lazy val attr_verticalQuietZone = attributes.get("@verticalQuietZone") map { _.as[Double] }
  lazy val attr_minColumns = attributes.get("@minColumns") map { _.as[Long] }
  lazy val attr_maxColumns = attributes.get("@maxColumns") map { _.as[Long] }
  lazy val attr_minRows = attributes.get("@minRows") map { _.as[Long] }
  lazy val attr_maxRows = attributes.get("@maxRows") map { _.as[Long] }
  lazy val attr_widthToHeightRatio = attributes.get("@widthToHeightRatio") map { _.as[Double] }
  lazy val attr_errorCorrectionLevel = attributes.get("@errorCorrectionLevel") map { _.as[Long] }
}

      

trait ErrorCorrectionLevel

object ErrorCorrectionLevel {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ErrorCorrectionLevel = value match {
    case "L" => L
    case "M" => M
    case "Q" => Q
    case "H" => H

  }
}

case object L extends ErrorCorrectionLevel { override def toString = "L" }
case object M extends ErrorCorrectionLevel { override def toString = "M" }
case object Q extends ErrorCorrectionLevel { override def toString = "Q" }
case object H extends ErrorCorrectionLevel { override def toString = "H" }


case class QRCode(codeExpression: com.iofficecorp.jasperserver.pumped.report.components.CodeExpression2,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends Barcodable {
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_margin = attributes.get("@margin") map { _.as[Long] }
  lazy val attr_errorCorrectionLevel = attributes.get("@errorCorrectionLevel") map { _.as[ErrorCorrectionLevel] }
}

      


case class LatitudeExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class LongitudeExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class AddressExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class ZoomExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class LanguageExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait MapTypeType

object MapTypeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): MapTypeType = value match {
    case "roadmap" => Roadmap
    case "satellite" => Satellite
    case "terrain" => Terrain
    case "hybrid" => Hybrid

  }
}

case object Roadmap extends MapTypeType { override def toString = "roadmap" }
case object Satellite extends MapTypeType { override def toString = "satellite" }
case object Terrain extends MapTypeType { override def toString = "terrain" }
case object Hybrid extends MapTypeType { override def toString = "hybrid" }

trait MapScale

object MapScale {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): MapScale = value match {
    case "1" => Number1
    case "2" => Number2
    case "4" => Number4

  }
}

case object Number1 extends MapScale { override def toString = "1" }
case object Number2 extends MapScale { override def toString = "2" }
case object Number4 extends MapScale { override def toString = "4" }

trait ImageType

object ImageType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ImageType = value match {
    case "png" => Png
    case "png8" => Png8
    case "png32" => Png32
    case "gif" => Gif
    case "jpg" => Jpg
    case "jpg-baseline" => Jpgu45baseline

  }
}

case object Png extends ImageType { override def toString = "png" }
case object Png8 extends ImageType { override def toString = "png8" }
case object Png32 extends ImageType { override def toString = "png32" }
case object Gif extends ImageType { override def toString = "gif" }
case object Jpg extends ImageType { override def toString = "jpg" }
case object Jpgu45baseline extends ImageType { override def toString = "jpg-baseline" }

trait OnErrorType

object OnErrorType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): OnErrorType = value match {
    case "Error" => Error
    case "Blank" => Blank
    case "Icon" => IconValue

  }
}

case object Error extends OnErrorType { override def toString = "Error" }
case object Blank extends OnErrorType { override def toString = "Blank" }
case object IconValue extends OnErrorType { override def toString = "Icon" }


case class MapType(latitudeExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.LatitudeExpression] = None,
  longitudeExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.LongitudeExpression] = None,
  addressExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.AddressExpression] = None,
  zoomExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.ZoomExpression] = None,
  languageExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.LanguageExpression] = None,
  maptypeoption: Option[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.components.MapTypeOption]] = None,
  pathStyle: Seq[com.iofficecorp.jasperserver.pumped.report.components.ItemData] = Nil,
  pathData: Seq[com.iofficecorp.jasperserver.pumped.report.components.ItemData] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends com.iofficecorp.jasperserver.pumped.report.ComponentType {
  lazy val attr_evaluationTime = attributes("@evaluationTime").as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime]
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_mapType = attributes("@mapType").as[MapTypeType]
  lazy val attr_mapScale = attributes("@mapScale").as[MapScale]
  lazy val attr_imageType = attributes("@imageType").as[ImageType]
  lazy val attr_onErrorType = attributes("@onErrorType").as[OnErrorType]
}

      

trait MapTypeOption
case class MapTypeSequence1(markerData: com.iofficecorp.jasperserver.pumped.report.components.ItemData*) extends MapTypeOption

case class ItemData(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  item: Seq[com.iofficecorp.jasperserver.pumped.report.components.Item] = Nil)
      


case class ItemProperty(valueExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_value = attributes.get("@value") map { _.as[String] }
}

      


case class Item(itemProperty: Seq[com.iofficecorp.jasperserver.pumped.report.components.ItemProperty] = Nil)
      


case class MarkerDataset(datasetRun: Option[com.iofficecorp.jasperserver.pumped.report.DatasetRun] = None,
  marker: Seq[com.iofficecorp.jasperserver.pumped.report.components.Marker] = Nil) extends MapTypeOption
      


case class Marker(markerProperty: Seq[com.iofficecorp.jasperserver.pumped.report.components.ItemProperty] = Nil)
      


case class Sort(symbol: Option[com.iofficecorp.jasperserver.pumped.report.components.Symbol] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends com.iofficecorp.jasperserver.pumped.report.ComponentType {
  lazy val attr_evaluationTime = attributes("@evaluationTime").as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime]
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
}

      

trait SortFieldType

object SortFieldType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): SortFieldType = value match {
    case "Field" => Field
    case "Variable" => Variable

  }
}

case object Field extends SortFieldType { override def toString = "Field" }
case object Variable extends SortFieldType { override def toString = "Variable" }

trait HandlerVerticalAlign

object HandlerVerticalAlign {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): HandlerVerticalAlign = value match {
    case "Top" => TopValue2
    case "Middle" => Middle
    case "Bottom" => BottomValue2

  }
}

case object TopValue2 extends HandlerVerticalAlign { override def toString = "Top" }
case object Middle extends HandlerVerticalAlign { override def toString = "Middle" }
case object BottomValue2 extends HandlerVerticalAlign { override def toString = "Bottom" }

trait HandlerHorizontalAlign

object HandlerHorizontalAlign {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): HandlerHorizontalAlign = value match {
    case "Left" => LeftTypeValue2
    case "Center" => Center
    case "Right" => RightTypeValue2

  }
}

case object LeftTypeValue2 extends HandlerHorizontalAlign { override def toString = "Left" }
case object Center extends HandlerHorizontalAlign { override def toString = "Center" }
case object RightTypeValue2 extends HandlerHorizontalAlign { override def toString = "Right" }


case class Symbol(font: Option[com.iofficecorp.jasperserver.pumped.report.Font] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_sortFieldName = attributes.get("@sortFieldName") map { _.as[String] }
  lazy val attr_handlerColor = attributes.get("@handlerColor") map { _.as[String] }
  lazy val attr_sortFieldType = attributes("@sortFieldType").as[SortFieldType]
  lazy val attr_handlerVerticalAlign = attributes.get("@handlerVerticalAlign") map { _.as[HandlerVerticalAlign] }
  lazy val attr_handlerHorizontalAlign = attributes.get("@handlerHorizontalAlign") map { _.as[HandlerHorizontalAlign] }
}

      

trait WhenNoDataType

object WhenNoDataType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): WhenNoDataType = value match {
    case "Blank" => BlankValue
    case "AllSectionsNoDetail" => AllSectionsNoDetail

  }
}

case object BlankValue extends WhenNoDataType { override def toString = "Blank" }
case object AllSectionsNoDetail extends WhenNoDataType { override def toString = "AllSectionsNoDetail" }


case class Table(datasetRun: com.iofficecorp.jasperserver.pumped.report.DatasetRun,
  tableoption: Seq[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.components.TableOption]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends com.iofficecorp.jasperserver.pumped.report.ComponentType {
  lazy val attr_whenNoDataType = attributes.get("@whenNoDataType") map { _.as[WhenNoDataType] }
}

      

trait TableOption

trait BaseColumnable {
  val property: Seq[com.iofficecorp.jasperserver.pumped.report.Property]
  val propertyExpression: Seq[com.iofficecorp.jasperserver.pumped.report.PropertyExpression]
  val printWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.PrintWhenExpression]
  val tableHeader: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell]
  val tableFooter: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell]
  val groupHeader: Seq[com.iofficecorp.jasperserver.pumped.report.components.TableGroupCell]
  val groupFooter: Seq[com.iofficecorp.jasperserver.pumped.report.components.TableGroupCell]
  val columnHeader: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell]
  val columnFooter: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell]
  val attr_uuid: Option[String]
  val attr_width: Long
}


case class BaseColumn(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  propertyExpression: Seq[com.iofficecorp.jasperserver.pumped.report.PropertyExpression] = Nil,
  printWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.PrintWhenExpression] = None,
  tableHeader: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  tableFooter: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  groupHeader: Seq[com.iofficecorp.jasperserver.pumped.report.components.TableGroupCell] = Nil,
  groupFooter: Seq[com.iofficecorp.jasperserver.pumped.report.components.TableGroupCell] = Nil,
  columnHeader: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  columnFooter: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BaseColumnable {
  lazy val attr_uuid = attributes.get("@uuid") map { _.as[String] }
  lazy val attr_width = attributes("@width").as[Long]
}

      


case class ColumnGroup(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  propertyExpression: Seq[com.iofficecorp.jasperserver.pumped.report.PropertyExpression] = Nil,
  printWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.PrintWhenExpression] = None,
  tableHeader: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  tableFooter: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  groupHeader: Seq[com.iofficecorp.jasperserver.pumped.report.components.TableGroupCell] = Nil,
  groupFooter: Seq[com.iofficecorp.jasperserver.pumped.report.components.TableGroupCell] = Nil,
  columnHeader: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  columnFooter: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  columngroupoption: Seq[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.components.ColumnGroupOption]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BaseColumnable with TableOption with ColumnGroupOption {
  lazy val attr_uuid = attributes.get("@uuid") map { _.as[String] }
  lazy val attr_width = attributes("@width").as[Long]
}

      

trait ColumnGroupOption

case class Column(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  propertyExpression: Seq[com.iofficecorp.jasperserver.pumped.report.PropertyExpression] = Nil,
  printWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.PrintWhenExpression] = None,
  tableHeader: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  tableFooter: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  groupHeader: Seq[com.iofficecorp.jasperserver.pumped.report.components.TableGroupCell] = Nil,
  groupFooter: Seq[com.iofficecorp.jasperserver.pumped.report.components.TableGroupCell] = Nil,
  columnHeader: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  columnFooter: Option[com.iofficecorp.jasperserver.pumped.report.components.TableCell] = None,
  detailCell: com.iofficecorp.jasperserver.pumped.report.components.TableCell,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BaseColumnable with TableOption with ColumnGroupOption {
  lazy val attr_uuid = attributes.get("@uuid") map { _.as[String] }
  lazy val attr_width = attributes("@width").as[Long]
}

      


case class TableGroupCell(cell: com.iofficecorp.jasperserver.pumped.report.components.TableCell,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_groupName = attributes("@groupName").as[String]
}

      


case class TableCell(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  box: Option[com.iofficecorp.jasperserver.pumped.report.Box] = None,
  tablecelloption: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_style = attributes.get("@style") map { _.as[String] }
  lazy val attr_height = attributes("@height").as[Long]
  lazy val attr_rowSpan = attributes.get("@rowSpan") map { _.as[Long] }
}

      

trait TableCellOption

case class SpiderChart(chartSettings: com.iofficecorp.jasperserver.pumped.report.components.ChartSettings,
  spiderDataset: com.iofficecorp.jasperserver.pumped.report.components.SpiderDataset,
  spiderPlot: com.iofficecorp.jasperserver.pumped.report.components.SpiderPlot,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends com.iofficecorp.jasperserver.pumped.report.ComponentType {
  lazy val attr_evaluationTime = attributes("@evaluationTime").as[com.iofficecorp.jasperserver.pumped.report.BasicEvaluationTime]
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
}

      

trait IsShowLegend

object IsShowLegend {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowLegend = value match {
    case "true" => True
    case "false" => False

  }
}

case object True extends IsShowLegend { override def toString = "true" }
case object False extends IsShowLegend { override def toString = "false" }


case class ChartSettings(chartTitle: Option[com.iofficecorp.jasperserver.pumped.report.ChartTitle] = None,
  chartSubtitle: Option[com.iofficecorp.jasperserver.pumped.report.ChartSubtitle] = None,
  chartLegend: Option[com.iofficecorp.jasperserver.pumped.report.ChartLegend] = None,
  anchorNameExpression: Option[com.iofficecorp.jasperserver.pumped.report.AnchorNameExpression] = None,
  hyperlinkReferenceExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkReferenceExpression] = None,
  hyperlinkWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkWhenExpression] = None,
  hyperlinkAnchorExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkAnchorExpression] = None,
  hyperlinkPageExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkPageExpression] = None,
  hyperlinkTooltipExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkTooltipExpression] = None,
  hyperlinkParameter: Seq[com.iofficecorp.jasperserver.pumped.report.HyperlinkParameter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isShowLegend = attributes.get("@isShowLegend") map { _.as[IsShowLegend] }
  lazy val attr_backcolor = attributes.get("@backcolor") map { _.as[String] }
  lazy val attr_hyperlinkType = attributes.get("@hyperlinkType") map { _.as[String] }
  lazy val attr_hyperlinkTarget = attributes.get("@hyperlinkTarget") map { _.as[String] }
  lazy val attr_bookmarkLevel = attributes("@bookmarkLevel").as[String]
  lazy val attr_customizerClass = attributes.get("@customizerClass") map { _.as[String] }
  lazy val attr_renderType = attributes.get("@renderType") map { _.as[String] }
}

      

trait RotationType

object RotationType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): RotationType = value match {
    case "Clockwise" => Clockwise
    case "Anticlockwise" => Anticlockwise

  }
}

case object Clockwise extends RotationType { override def toString = "Clockwise" }
case object Anticlockwise extends RotationType { override def toString = "Anticlockwise" }

trait TableOrder

object TableOrder {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TableOrder = value match {
    case "Row" => Row
    case "Column" => ColumnValue

  }
}

case object Row extends TableOrder { override def toString = "Row" }
case object ColumnValue extends TableOrder { override def toString = "Column" }

trait IsWebFilled

object IsWebFilled {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsWebFilled = value match {
    case "true" => TrueValue
    case "false" => FalseValue

  }
}

case object TrueValue extends IsWebFilled { override def toString = "true" }
case object FalseValue extends IsWebFilled { override def toString = "false" }


case class MaxValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class SpiderPlot(labelFont: Option[com.iofficecorp.jasperserver.pumped.report.LabelFont] = None,
  maxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.components.MaxValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_rotation = attributes.get("@rotation") map { _.as[RotationType] }
  lazy val attr_tableOrder = attributes.get("@tableOrder") map { _.as[TableOrder] }
  lazy val attr_isWebFilled = attributes.get("@isWebFilled") map { _.as[IsWebFilled] }
  lazy val attr_startAngle = attributes.get("@startAngle") map { _.as[String] }
  lazy val attr_headPercent = attributes.get("@headPercent") map { _.as[String] }
  lazy val attr_interiorGap = attributes.get("@interiorGap") map { _.as[String] }
  lazy val attr_axisLineColor = attributes.get("@axisLineColor") map { _.as[String] }
  lazy val attr_axisLineWidth = attributes.get("@axisLineWidth") map { _.as[String] }
  lazy val attr_labelGap = attributes.get("@labelGap") map { _.as[String] }
  lazy val attr_labelColor = attributes.get("@labelColor") map { _.as[String] }
  lazy val attr_backcolor = attributes.get("@backcolor") map { _.as[String] }
  lazy val attr_backgroundAlpha = attributes.get("@backgroundAlpha") map { _.as[String] }
  lazy val attr_foregroundAlpha = attributes.get("@foregroundAlpha") map { _.as[String] }
}

      


case class SpiderDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  categorySeries: Seq[com.iofficecorp.jasperserver.pumped.report.CategorySeries] = Nil)
      

trait IconPosition

object IconPosition {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IconPosition = value match {
    case "Start" => Start
    case "End" => End

  }
}

case object Start extends IconPosition { override def toString = "Start" }
case object End extends IconPosition { override def toString = "End" }

trait LabelFill

object LabelFill {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): LabelFill = value match {
    case "None" => NoneTypeValue2
    case "Horizontal" => HorizontalValue
    case "Vertical" => VerticalValue
    case "Both" => Both

  }
}

case object NoneTypeValue2 extends LabelFill { override def toString = "None" }
case object HorizontalValue extends LabelFill { override def toString = "Horizontal" }
case object VerticalValue extends LabelFill { override def toString = "Vertical" }
case object Both extends LabelFill { override def toString = "Both" }

trait HorizontalAlignment

object HorizontalAlignment {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): HorizontalAlignment = value match {
    case "Left" => LeftTypeValue3
    case "Center" => CenterValue
    case "Right" => RightTypeValue3

  }
}

case object LeftTypeValue3 extends HorizontalAlignment { override def toString = "Left" }
case object CenterValue extends HorizontalAlignment { override def toString = "Center" }
case object RightTypeValue3 extends HorizontalAlignment { override def toString = "Right" }

trait VerticalAlignment

object VerticalAlignment {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): VerticalAlignment = value match {
    case "Top" => TopValue3
    case "Middle" => MiddleValue
    case "Bottom" => BottomValue3

  }
}

case object TopValue3 extends VerticalAlignment { override def toString = "Top" }
case object MiddleValue extends VerticalAlignment { override def toString = "Middle" }
case object BottomValue3 extends VerticalAlignment { override def toString = "Bottom" }


case class IconLabel(box: Option[com.iofficecorp.jasperserver.pumped.report.Box] = None,
  label: com.iofficecorp.jasperserver.pumped.report.components.Label,
  icon: com.iofficecorp.jasperserver.pumped.report.components.Icon,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends com.iofficecorp.jasperserver.pumped.report.ComponentType {
  lazy val attr_iconPosition = attributes.get("@iconPosition") map { _.as[IconPosition] }
  lazy val attr_labelFill = attributes.get("@labelFill") map { _.as[LabelFill] }
  lazy val attr_horizontalAlignment = attributes.get("@horizontalAlignment") map { _.as[HorizontalAlignment] }
  lazy val attr_verticalAlignment = attributes.get("@verticalAlignment") map { _.as[VerticalAlignment] }
}

      


case class Label(textField: com.iofficecorp.jasperserver.pumped.report.TextField)
      


case class Icon(textField: com.iofficecorp.jasperserver.pumped.report.TextField)
      

