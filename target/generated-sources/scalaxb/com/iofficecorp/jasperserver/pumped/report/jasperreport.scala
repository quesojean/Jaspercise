// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package com.iofficecorp.jasperserver.pumped.report

trait PrintOrder

object PrintOrder {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): PrintOrder = value match {
    case "Vertical" => Vertical
    case "Horizontal" => Horizontal

  }
}

case object Vertical extends PrintOrder { override def toString = "Vertical" }
case object Horizontal extends PrintOrder { override def toString = "Horizontal" }

trait ColumnDirection

object ColumnDirection {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ColumnDirection = value match {
    case "LTR" => LTR
    case "RTL" => RTL

  }
}

case object LTR extends ColumnDirection { override def toString = "LTR" }
case object RTL extends ColumnDirection { override def toString = "RTL" }

trait Orientation

object Orientation {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Orientation = value match {
    case "Portrait" => Portrait
    case "Landscape" => Landscape

  }
}

case object Portrait extends Orientation { override def toString = "Portrait" }
case object Landscape extends Orientation { override def toString = "Landscape" }

trait WhenNoDataType

object WhenNoDataType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): WhenNoDataType = value match {
    case "NoPages" => NoPages
    case "BlankPage" => BlankPage
    case "AllSectionsNoDetail" => AllSectionsNoDetail
    case "NoDataSection" => NoDataSection

  }
}

case object NoPages extends WhenNoDataType { override def toString = "NoPages" }
case object BlankPage extends WhenNoDataType { override def toString = "BlankPage" }
case object AllSectionsNoDetail extends WhenNoDataType { override def toString = "AllSectionsNoDetail" }
case object NoDataSection extends WhenNoDataType { override def toString = "NoDataSection" }

trait SectionType

object SectionType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): SectionType = value match {
    case "Band" => BandValue3
    case "Part" => PartValue

  }
}

case object BandValue3 extends SectionType { override def toString = "Band" }
case object PartValue extends SectionType { override def toString = "Part" }

trait IsTitleNewPage

object IsTitleNewPage {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsTitleNewPage = value match {
    case "true" => True
    case "false" => False

  }
}

case object True extends IsTitleNewPage { override def toString = "true" }
case object False extends IsTitleNewPage { override def toString = "false" }

trait IsSummaryNewPage

object IsSummaryNewPage {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsSummaryNewPage = value match {
    case "true" => TrueValue
    case "false" => FalseValue

  }
}

case object TrueValue extends IsSummaryNewPage { override def toString = "true" }
case object FalseValue extends IsSummaryNewPage { override def toString = "false" }

trait IsSummaryWithPageHeaderAndFooter

object IsSummaryWithPageHeaderAndFooter {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsSummaryWithPageHeaderAndFooter = value match {
    case "true" => TrueValue2
    case "false" => FalseValue2

  }
}

case object TrueValue2 extends IsSummaryWithPageHeaderAndFooter { override def toString = "true" }
case object FalseValue2 extends IsSummaryWithPageHeaderAndFooter { override def toString = "false" }

trait IsFloatColumnFooter

object IsFloatColumnFooter {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsFloatColumnFooter = value match {
    case "true" => TrueValue3
    case "false" => FalseValue3

  }
}

case object TrueValue3 extends IsFloatColumnFooter { override def toString = "true" }
case object FalseValue3 extends IsFloatColumnFooter { override def toString = "false" }

trait WhenResourceMissingType

object WhenResourceMissingType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): WhenResourceMissingType = value match {
    case "Null" => Null
    case "Empty" => Empty
    case "Key" => Key
    case "Error" => Error

  }
}

case object Null extends WhenResourceMissingType { override def toString = "Null" }
case object Empty extends WhenResourceMissingType { override def toString = "Empty" }
case object Key extends WhenResourceMissingType { override def toString = "Key" }
case object Error extends WhenResourceMissingType { override def toString = "Error" }

trait IsIgnorePagination

object IsIgnorePagination {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsIgnorePagination = value match {
    case "true" => TrueValue4
    case "false" => FalseValue4

  }
}

case object TrueValue4 extends IsIgnorePagination { override def toString = "true" }
case object FalseValue4 extends IsIgnorePagination { override def toString = "false" }


case class JasperReport(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  importValue: Seq[com.iofficecorp.jasperserver.pumped.report.Import] = Nil,
  template: Seq[com.iofficecorp.jasperserver.pumped.report.Template] = Nil,
  reportFont: Seq[com.iofficecorp.jasperserver.pumped.report.ReportFont] = Nil,
  style: Seq[com.iofficecorp.jasperserver.pumped.report.Style] = Nil,
  subDataset: Seq[com.iofficecorp.jasperserver.pumped.report.SubDataset] = Nil,
  scriptlet: Seq[com.iofficecorp.jasperserver.pumped.report.Scriptlet] = Nil,
  parameter: Seq[com.iofficecorp.jasperserver.pumped.report.Parameter] = Nil,
  queryString: Option[com.iofficecorp.jasperserver.pumped.report.QueryString] = None,
  field: Seq[com.iofficecorp.jasperserver.pumped.report.Field] = Nil,
  sortField: Seq[com.iofficecorp.jasperserver.pumped.report.SortField] = Nil,
  variable: Seq[com.iofficecorp.jasperserver.pumped.report.Variable] = Nil,
  filterExpression: Option[com.iofficecorp.jasperserver.pumped.report.FilterExpression] = None,
  group: Seq[com.iofficecorp.jasperserver.pumped.report.Group] = Nil,
  background: Option[com.iofficecorp.jasperserver.pumped.report.Background] = None,
  title: Option[com.iofficecorp.jasperserver.pumped.report.Title] = None,
  pageHeader: Option[com.iofficecorp.jasperserver.pumped.report.PageHeader] = None,
  columnHeader: Option[com.iofficecorp.jasperserver.pumped.report.ColumnHeader] = None,
  detail: Option[com.iofficecorp.jasperserver.pumped.report.Detail] = None,
  columnFooter: Option[com.iofficecorp.jasperserver.pumped.report.ColumnFooter] = None,
  pageFooter: Option[com.iofficecorp.jasperserver.pumped.report.PageFooter] = None,
  lastPageFooter: Option[com.iofficecorp.jasperserver.pumped.report.LastPageFooter] = None,
  summary: Option[com.iofficecorp.jasperserver.pumped.report.Summary] = None,
  noData: Option[com.iofficecorp.jasperserver.pumped.report.NoData] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_language = attributes("@language").as[String]
  lazy val attr_columnCount = attributes("@columnCount").as[String]
  lazy val attr_printOrder = attributes("@printOrder").as[PrintOrder]
  lazy val attr_columnDirection = attributes("@columnDirection").as[ColumnDirection]
  lazy val attr_pageWidth = attributes("@pageWidth").as[String]
  lazy val attr_pageHeight = attributes("@pageHeight").as[String]
  lazy val attr_orientation = attributes("@orientation").as[Orientation]
  lazy val attr_whenNoDataType = attributes("@whenNoDataType").as[WhenNoDataType]
  lazy val attr_sectionType = attributes("@sectionType").as[SectionType]
  lazy val attr_columnWidth = attributes("@columnWidth").as[String]
  lazy val attr_columnSpacing = attributes("@columnSpacing").as[String]
  lazy val attr_leftMargin = attributes("@leftMargin").as[String]
  lazy val attr_rightMargin = attributes("@rightMargin").as[String]
  lazy val attr_topMargin = attributes("@topMargin").as[String]
  lazy val attr_bottomMargin = attributes("@bottomMargin").as[String]
  lazy val attr_isTitleNewPage = attributes("@isTitleNewPage").as[IsTitleNewPage]
  lazy val attr_isSummaryNewPage = attributes("@isSummaryNewPage").as[IsSummaryNewPage]
  lazy val attr_isSummaryWithPageHeaderAndFooter = attributes("@isSummaryWithPageHeaderAndFooter").as[IsSummaryWithPageHeaderAndFooter]
  lazy val attr_isFloatColumnFooter = attributes("@isFloatColumnFooter").as[IsFloatColumnFooter]
  lazy val attr_scriptletClass = attributes.get("@scriptletClass") map { _.as[String] }
  lazy val attr_resourceBundle = attributes.get("@resourceBundle") map { _.as[String] }
  lazy val attr_whenResourceMissingType = attributes("@whenResourceMissingType").as[WhenResourceMissingType]
  lazy val attr_isIgnorePagination = attributes("@isIgnorePagination").as[IsIgnorePagination]
  lazy val attr_formatFactoryClass = attributes.get("@formatFactoryClass") map { _.as[String] }
  lazy val attr_uuid = attributes.get("@uuid") map { _.as[String] }
}

      


case class Property(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_value = attributes.get("@value") map { _.as[String] }
}

      


case class PropertyExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
}

      


case class Import(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_value = attributes("@value").as[String]
}

      


case class Template(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_class = attributes("@class").as[String]
}

      

trait IsDefault

object IsDefault {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsDefault = value match {
    case "true" => TrueValue5
    case "false" => FalseValue5

  }
}

case object TrueValue5 extends IsDefault { override def toString = "true" }
case object FalseValue5 extends IsDefault { override def toString = "false" }

trait IsBold

object IsBold {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsBold = value match {
    case "true" => TrueValue6
    case "false" => FalseValue6

  }
}

case object TrueValue6 extends IsBold { override def toString = "true" }
case object FalseValue6 extends IsBold { override def toString = "false" }

trait IsItalic

object IsItalic {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsItalic = value match {
    case "true" => TrueValue7
    case "false" => FalseValue7

  }
}

case object TrueValue7 extends IsItalic { override def toString = "true" }
case object FalseValue7 extends IsItalic { override def toString = "false" }

trait IsUnderline

object IsUnderline {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsUnderline = value match {
    case "true" => TrueValue8
    case "false" => FalseValue8

  }
}

case object TrueValue8 extends IsUnderline { override def toString = "true" }
case object FalseValue8 extends IsUnderline { override def toString = "false" }

trait IsStrikeThrough

object IsStrikeThrough {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsStrikeThrough = value match {
    case "true" => TrueValue9
    case "false" => FalseValue9

  }
}

case object TrueValue9 extends IsStrikeThrough { override def toString = "true" }
case object FalseValue9 extends IsStrikeThrough { override def toString = "false" }

trait IsPdfEmbedded

object IsPdfEmbedded {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsPdfEmbedded = value match {
    case "true" => TrueValue10
    case "false" => FalseValue10

  }
}

case object TrueValue10 extends IsPdfEmbedded { override def toString = "true" }
case object FalseValue10 extends IsPdfEmbedded { override def toString = "false" }


case class ReportFont(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_isDefault = attributes("@isDefault").as[IsDefault]
  lazy val attr_fontName = attributes.get("@fontName") map { _.as[String] }
  lazy val attr_size = attributes.get("@size") map { _.as[String] }
  lazy val attr_isBold = attributes.get("@isBold") map { _.as[IsBold] }
  lazy val attr_isItalic = attributes.get("@isItalic") map { _.as[IsItalic] }
  lazy val attr_isUnderline = attributes.get("@isUnderline") map { _.as[IsUnderline] }
  lazy val attr_isStrikeThrough = attributes.get("@isStrikeThrough") map { _.as[IsStrikeThrough] }
  lazy val attr_pdfFontName = attributes.get("@pdfFontName") map { _.as[String] }
  lazy val attr_pdfEncoding = attributes.get("@pdfEncoding") map { _.as[String] }
  lazy val attr_isPdfEmbedded = attributes.get("@isPdfEmbedded") map { _.as[IsPdfEmbedded] }
}

      

trait IsDefaultType

object IsDefaultType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsDefaultType = value match {
    case "true" => TrueValue11
    case "false" => FalseValue11

  }
}

case object TrueValue11 extends IsDefaultType { override def toString = "true" }
case object FalseValue11 extends IsDefaultType { override def toString = "false" }

trait Mode

object Mode {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Mode = value match {
    case "Opaque" => Opaque
    case "Transparent" => Transparent

  }
}

case object Opaque extends Mode { override def toString = "Opaque" }
case object Transparent extends Mode { override def toString = "Transparent" }

trait PenType

object PenType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): PenType = value match {
    case "None" => NoneType
    case "Thin" => Thin
    case "1Point" => Number1Point
    case "2Point" => Number2Point
    case "4Point" => Number4Point
    case "Dotted" => Dotted

  }
}

case object NoneType extends PenType { override def toString = "None" }
case object Thin extends PenType { override def toString = "Thin" }
case object Number1Point extends PenType { override def toString = "1Point" }
case object Number2Point extends PenType { override def toString = "2Point" }
case object Number4Point extends PenType { override def toString = "4Point" }
case object Dotted extends PenType { override def toString = "Dotted" }

trait Fill

object Fill {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Fill = value match {
    case "Solid" => Solid

  }
}

case object Solid extends Fill { override def toString = "Solid" }

trait ScaleImage

object ScaleImage {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ScaleImage = value match {
    case "Clip" => Clip
    case "FillFrame" => FillFrame
    case "RetainShape" => RetainShape
    case "RealHeight" => RealHeight
    case "RealSize" => RealSize

  }
}

case object Clip extends ScaleImage { override def toString = "Clip" }
case object FillFrame extends ScaleImage { override def toString = "FillFrame" }
case object RetainShape extends ScaleImage { override def toString = "RetainShape" }
case object RealHeight extends ScaleImage { override def toString = "RealHeight" }
case object RealSize extends ScaleImage { override def toString = "RealSize" }

trait HAlign

object HAlign {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): HAlign = value match {
    case "Left" => LeftType
    case "Center" => Center
    case "Right" => RightType
    case "Justified" => Justified

  }
}

case object LeftType extends HAlign { override def toString = "Left" }
case object Center extends HAlign { override def toString = "Center" }
case object RightType extends HAlign { override def toString = "Right" }
case object Justified extends HAlign { override def toString = "Justified" }

trait HTextAlign

object HTextAlign {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): HTextAlign = value match {
    case "Left" => LeftTypeValue
    case "Center" => CenterValue
    case "Right" => RightTypeValue
    case "Justified" => JustifiedValue

  }
}

case object LeftTypeValue extends HTextAlign { override def toString = "Left" }
case object CenterValue extends HTextAlign { override def toString = "Center" }
case object RightTypeValue extends HTextAlign { override def toString = "Right" }
case object JustifiedValue extends HTextAlign { override def toString = "Justified" }

trait HImageAlign

object HImageAlign {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): HImageAlign = value match {
    case "Left" => LeftTypeValue2
    case "Center" => CenterValue2
    case "Right" => RightTypeValue2

  }
}

case object LeftTypeValue2 extends HImageAlign { override def toString = "Left" }
case object CenterValue2 extends HImageAlign { override def toString = "Center" }
case object RightTypeValue2 extends HImageAlign { override def toString = "Right" }

trait VAlign

object VAlign {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): VAlign = value match {
    case "Top" => Top
    case "Middle" => Middle
    case "Bottom" => Bottom

  }
}

case object Top extends VAlign { override def toString = "Top" }
case object Middle extends VAlign { override def toString = "Middle" }
case object Bottom extends VAlign { override def toString = "Bottom" }

trait VTextAlign

object VTextAlign {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): VTextAlign = value match {
    case "Top" => TopValue
    case "Middle" => MiddleValue
    case "Bottom" => BottomValue

  }
}

case object TopValue extends VTextAlign { override def toString = "Top" }
case object MiddleValue extends VTextAlign { override def toString = "Middle" }
case object BottomValue extends VTextAlign { override def toString = "Bottom" }

trait VImageAlign

object VImageAlign {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): VImageAlign = value match {
    case "Top" => TopValue2
    case "Middle" => MiddleValue2
    case "Bottom" => BottomValue2

  }
}

case object TopValue2 extends VImageAlign { override def toString = "Top" }
case object MiddleValue2 extends VImageAlign { override def toString = "Middle" }
case object BottomValue2 extends VImageAlign { override def toString = "Bottom" }

trait Border

object Border {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Border = value match {
    case "None" => NoneTypeValue
    case "Thin" => ThinValue
    case "1Point" => Number1PointValue
    case "2Point" => Number2PointValue
    case "4Point" => Number4PointValue
    case "Dotted" => DottedValue

  }
}

case object NoneTypeValue extends Border { override def toString = "None" }
case object ThinValue extends Border { override def toString = "Thin" }
case object Number1PointValue extends Border { override def toString = "1Point" }
case object Number2PointValue extends Border { override def toString = "2Point" }
case object Number4PointValue extends Border { override def toString = "4Point" }
case object DottedValue extends Border { override def toString = "Dotted" }

trait TopBorder

object TopBorder {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TopBorder = value match {
    case "None" => NoneTypeValue2
    case "Thin" => ThinValue2
    case "1Point" => Number1PointValue2
    case "2Point" => Number2PointValue2
    case "4Point" => Number4PointValue2
    case "Dotted" => DottedValue2

  }
}

case object NoneTypeValue2 extends TopBorder { override def toString = "None" }
case object ThinValue2 extends TopBorder { override def toString = "Thin" }
case object Number1PointValue2 extends TopBorder { override def toString = "1Point" }
case object Number2PointValue2 extends TopBorder { override def toString = "2Point" }
case object Number4PointValue2 extends TopBorder { override def toString = "4Point" }
case object DottedValue2 extends TopBorder { override def toString = "Dotted" }

trait LeftBorder

object LeftBorder {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): LeftBorder = value match {
    case "None" => NoneTypeValue3
    case "Thin" => ThinValue3
    case "1Point" => Number1PointValue3
    case "2Point" => Number2PointValue3
    case "4Point" => Number4PointValue3
    case "Dotted" => DottedValue3

  }
}

case object NoneTypeValue3 extends LeftBorder { override def toString = "None" }
case object ThinValue3 extends LeftBorder { override def toString = "Thin" }
case object Number1PointValue3 extends LeftBorder { override def toString = "1Point" }
case object Number2PointValue3 extends LeftBorder { override def toString = "2Point" }
case object Number4PointValue3 extends LeftBorder { override def toString = "4Point" }
case object DottedValue3 extends LeftBorder { override def toString = "Dotted" }

trait BottomBorder

object BottomBorder {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): BottomBorder = value match {
    case "None" => NoneTypeValue4
    case "Thin" => ThinValue4
    case "1Point" => Number1PointValue4
    case "2Point" => Number2PointValue4
    case "4Point" => Number4PointValue4
    case "Dotted" => DottedValue4

  }
}

case object NoneTypeValue4 extends BottomBorder { override def toString = "None" }
case object ThinValue4 extends BottomBorder { override def toString = "Thin" }
case object Number1PointValue4 extends BottomBorder { override def toString = "1Point" }
case object Number2PointValue4 extends BottomBorder { override def toString = "2Point" }
case object Number4PointValue4 extends BottomBorder { override def toString = "4Point" }
case object DottedValue4 extends BottomBorder { override def toString = "Dotted" }

trait RightBorder

object RightBorder {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): RightBorder = value match {
    case "None" => NoneTypeValue5
    case "Thin" => ThinValue5
    case "1Point" => Number1PointValue5
    case "2Point" => Number2PointValue5
    case "4Point" => Number4PointValue5
    case "Dotted" => DottedValue5

  }
}

case object NoneTypeValue5 extends RightBorder { override def toString = "None" }
case object ThinValue5 extends RightBorder { override def toString = "Thin" }
case object Number1PointValue5 extends RightBorder { override def toString = "1Point" }
case object Number2PointValue5 extends RightBorder { override def toString = "2Point" }
case object Number4PointValue5 extends RightBorder { override def toString = "4Point" }
case object DottedValue5 extends RightBorder { override def toString = "Dotted" }

trait Rotation

object Rotation {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Rotation = value match {
    case "None" => NoneTypeValue6
    case "Left" => LeftTypeValue3
    case "Right" => RightTypeValue3
    case "UpsideDown" => UpsideDown

  }
}

case object NoneTypeValue6 extends Rotation { override def toString = "None" }
case object LeftTypeValue3 extends Rotation { override def toString = "Left" }
case object RightTypeValue3 extends Rotation { override def toString = "Right" }
case object UpsideDown extends Rotation { override def toString = "UpsideDown" }

trait LineSpacing

object LineSpacing {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): LineSpacing = value match {
    case "Single" => Single
    case "1_1_2" => Number1_1_2
    case "Double" => DoubleType

  }
}

case object Single extends LineSpacing { override def toString = "Single" }
case object Number1_1_2 extends LineSpacing { override def toString = "1_1_2" }
case object DoubleType extends LineSpacing { override def toString = "Double" }

trait IsStyledText

object IsStyledText {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsStyledText = value match {
    case "true" => TrueValue12
    case "false" => FalseValue12

  }
}

case object TrueValue12 extends IsStyledText { override def toString = "true" }
case object FalseValue12 extends IsStyledText { override def toString = "false" }

trait IsBoldType

object IsBoldType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsBoldType = value match {
    case "true" => TrueValue13
    case "false" => FalseValue13

  }
}

case object TrueValue13 extends IsBoldType { override def toString = "true" }
case object FalseValue13 extends IsBoldType { override def toString = "false" }

trait IsItalicType

object IsItalicType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsItalicType = value match {
    case "true" => TrueValue14
    case "false" => FalseValue14

  }
}

case object TrueValue14 extends IsItalicType { override def toString = "true" }
case object FalseValue14 extends IsItalicType { override def toString = "false" }

trait IsUnderlineType

object IsUnderlineType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsUnderlineType = value match {
    case "true" => TrueValue15
    case "false" => FalseValue15

  }
}

case object TrueValue15 extends IsUnderlineType { override def toString = "true" }
case object FalseValue15 extends IsUnderlineType { override def toString = "false" }

trait IsStrikeThroughType

object IsStrikeThroughType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsStrikeThroughType = value match {
    case "true" => TrueValue16
    case "false" => FalseValue16

  }
}

case object TrueValue16 extends IsStrikeThroughType { override def toString = "true" }
case object FalseValue16 extends IsStrikeThroughType { override def toString = "false" }

trait IsPdfEmbeddedType

object IsPdfEmbeddedType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsPdfEmbeddedType = value match {
    case "true" => TrueValue17
    case "false" => FalseValue17

  }
}

case object TrueValue17 extends IsPdfEmbeddedType { override def toString = "true" }
case object FalseValue17 extends IsPdfEmbeddedType { override def toString = "false" }

trait IsBlankWhenNull

object IsBlankWhenNull {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsBlankWhenNull = value match {
    case "true" => TrueValue18
    case "false" => FalseValue18

  }
}

case object TrueValue18 extends IsBlankWhenNull { override def toString = "true" }
case object FalseValue18 extends IsBlankWhenNull { override def toString = "false" }


case class Style(pen: Option[com.iofficecorp.jasperserver.pumped.report.Pen] = None,
  box: Option[com.iofficecorp.jasperserver.pumped.report.Box] = None,
  paragraph: Option[com.iofficecorp.jasperserver.pumped.report.Paragraph] = None,
  conditionalStyle: Seq[com.iofficecorp.jasperserver.pumped.report.ConditionalStyle] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes.get("@name") map { _.as[String] }
  lazy val attr_isDefault = attributes.get("@isDefault") map { _.as[IsDefaultType] }
  lazy val attr_style = attributes.get("@style") map { _.as[String] }
  lazy val attr_mode = attributes.get("@mode") map { _.as[Mode] }
  lazy val attr_forecolor = attributes.get("@forecolor") map { _.as[String] }
  lazy val attr_backcolor = attributes.get("@backcolor") map { _.as[String] }
  lazy val attr_pen = attributes.get("@pen") map { _.as[PenType] }
  lazy val attr_fill = attributes.get("@fill") map { _.as[Fill] }
  lazy val attr_radius = attributes.get("@radius") map { _.as[String] }
  lazy val attr_scaleImage = attributes.get("@scaleImage") map { _.as[ScaleImage] }
  lazy val attr_hAlign = attributes.get("@hAlign") map { _.as[HAlign] }
  lazy val attr_hTextAlign = attributes.get("@hTextAlign") map { _.as[HTextAlign] }
  lazy val attr_hImageAlign = attributes.get("@hImageAlign") map { _.as[HImageAlign] }
  lazy val attr_vAlign = attributes.get("@vAlign") map { _.as[VAlign] }
  lazy val attr_vTextAlign = attributes.get("@vTextAlign") map { _.as[VTextAlign] }
  lazy val attr_vImageAlign = attributes.get("@vImageAlign") map { _.as[VImageAlign] }
  lazy val attr_border = attributes.get("@border") map { _.as[Border] }
  lazy val attr_borderColor = attributes.get("@borderColor") map { _.as[String] }
  lazy val attr_padding = attributes.get("@padding") map { _.as[String] }
  lazy val attr_topBorder = attributes.get("@topBorder") map { _.as[TopBorder] }
  lazy val attr_topBorderColor = attributes.get("@topBorderColor") map { _.as[String] }
  lazy val attr_topPadding = attributes.get("@topPadding") map { _.as[String] }
  lazy val attr_leftBorder = attributes.get("@leftBorder") map { _.as[LeftBorder] }
  lazy val attr_leftBorderColor = attributes.get("@leftBorderColor") map { _.as[String] }
  lazy val attr_leftPadding = attributes.get("@leftPadding") map { _.as[String] }
  lazy val attr_bottomBorder = attributes.get("@bottomBorder") map { _.as[BottomBorder] }
  lazy val attr_bottomBorderColor = attributes.get("@bottomBorderColor") map { _.as[String] }
  lazy val attr_bottomPadding = attributes.get("@bottomPadding") map { _.as[String] }
  lazy val attr_rightBorder = attributes.get("@rightBorder") map { _.as[RightBorder] }
  lazy val attr_rightBorderColor = attributes.get("@rightBorderColor") map { _.as[String] }
  lazy val attr_rightPadding = attributes.get("@rightPadding") map { _.as[String] }
  lazy val attr_rotation = attributes.get("@rotation") map { _.as[Rotation] }
  lazy val attr_lineSpacing = attributes.get("@lineSpacing") map { _.as[LineSpacing] }
  lazy val attr_isStyledText = attributes.get("@isStyledText") map { _.as[IsStyledText] }
  lazy val attr_markup = attributes.get("@markup") map { _.as[String] }
  lazy val attr_fontName = attributes.get("@fontName") map { _.as[String] }
  lazy val attr_fontSize = attributes.get("@fontSize") map { _.as[String] }
  lazy val attr_isBold = attributes.get("@isBold") map { _.as[IsBoldType] }
  lazy val attr_isItalic = attributes.get("@isItalic") map { _.as[IsItalicType] }
  lazy val attr_isUnderline = attributes.get("@isUnderline") map { _.as[IsUnderlineType] }
  lazy val attr_isStrikeThrough = attributes.get("@isStrikeThrough") map { _.as[IsStrikeThroughType] }
  lazy val attr_pdfFontName = attributes.get("@pdfFontName") map { _.as[String] }
  lazy val attr_pdfEncoding = attributes.get("@pdfEncoding") map { _.as[String] }
  lazy val attr_isPdfEmbedded = attributes.get("@isPdfEmbedded") map { _.as[IsPdfEmbeddedType] }
  lazy val attr_pattern = attributes.get("@pattern") map { _.as[String] }
  lazy val attr_isBlankWhenNull = attributes.get("@isBlankWhenNull") map { _.as[IsBlankWhenNull] }
}

      

trait LineStyle

object LineStyle {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): LineStyle = value match {
    case "Solid" => SolidValue
    case "Dashed" => Dashed
    case "Dotted" => DottedValue6
    case "Double" => DoubleTypeValue

  }
}

case object SolidValue extends LineStyle { override def toString = "Solid" }
case object Dashed extends LineStyle { override def toString = "Dashed" }
case object DottedValue6 extends LineStyle { override def toString = "Dotted" }
case object DoubleTypeValue extends LineStyle { override def toString = "Double" }


case class Pen(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_lineWidth = attributes.get("@lineWidth") map { _.as[String] }
  lazy val attr_lineStyle = attributes.get("@lineStyle") map { _.as[LineStyle] }
  lazy val attr_lineColor = attributes.get("@lineColor") map { _.as[String] }
}

      

trait LineSpacingType

object LineSpacingType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): LineSpacingType = value match {
    case "Single" => SingleValue
    case "1_1_2" => Number1_1_2Value
    case "Double" => DoubleTypeValue2
    case "AtLeast" => AtLeast
    case "Fixed" => Fixed
    case "Proportional" => Proportional

  }
}

case object SingleValue extends LineSpacingType { override def toString = "Single" }
case object Number1_1_2Value extends LineSpacingType { override def toString = "1_1_2" }
case object DoubleTypeValue2 extends LineSpacingType { override def toString = "Double" }
case object AtLeast extends LineSpacingType { override def toString = "AtLeast" }
case object Fixed extends LineSpacingType { override def toString = "Fixed" }
case object Proportional extends LineSpacingType { override def toString = "Proportional" }


case class Paragraph(tabStop: Seq[com.iofficecorp.jasperserver.pumped.report.TabStop] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_lineSpacing = attributes.get("@lineSpacing") map { _.as[LineSpacingType] }
  lazy val attr_lineSpacingSize = attributes.get("@lineSpacingSize") map { _.as[String] }
  lazy val attr_firstLineIndent = attributes.get("@firstLineIndent") map { _.as[String] }
  lazy val attr_leftIndent = attributes.get("@leftIndent") map { _.as[String] }
  lazy val attr_rightIndent = attributes.get("@rightIndent") map { _.as[String] }
  lazy val attr_spacingBefore = attributes.get("@spacingBefore") map { _.as[String] }
  lazy val attr_spacingAfter = attributes.get("@spacingAfter") map { _.as[String] }
  lazy val attr_tabStopWidth = attributes.get("@tabStopWidth") map { _.as[String] }
}

      

trait Alignment

object Alignment {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Alignment = value match {
    case "Left" => LeftTypeValue4
    case "Center" => CenterValue3
    case "Right" => RightTypeValue4

  }
}

case object LeftTypeValue4 extends Alignment { override def toString = "Left" }
case object CenterValue3 extends Alignment { override def toString = "Center" }
case object RightTypeValue4 extends Alignment { override def toString = "Right" }


case class TabStop(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_alignment = attributes.get("@alignment") map { _.as[Alignment] }
  lazy val attr_position = attributes("@position").as[String]
}

      


case class ConditionalStyle(conditionExpression: Option[com.iofficecorp.jasperserver.pumped.report.ConditionExpression] = None,
  style: com.iofficecorp.jasperserver.pumped.report.Style)
      


case class ConditionExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait WhenResourceMissingTypeType

object WhenResourceMissingTypeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): WhenResourceMissingTypeType = value match {
    case "Null" => NullValue
    case "Empty" => EmptyValue
    case "Key" => KeyValue
    case "Error" => ErrorValue

  }
}

case object NullValue extends WhenResourceMissingTypeType { override def toString = "Null" }
case object EmptyValue extends WhenResourceMissingTypeType { override def toString = "Empty" }
case object KeyValue extends WhenResourceMissingTypeType { override def toString = "Key" }
case object ErrorValue extends WhenResourceMissingTypeType { override def toString = "Error" }


case class SubDataset(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  scriptlet: Seq[com.iofficecorp.jasperserver.pumped.report.Scriptlet] = Nil,
  parameter: Seq[com.iofficecorp.jasperserver.pumped.report.Parameter] = Nil,
  queryString: Option[com.iofficecorp.jasperserver.pumped.report.QueryString] = None,
  field: Seq[com.iofficecorp.jasperserver.pumped.report.Field] = Nil,
  sortField: Seq[com.iofficecorp.jasperserver.pumped.report.SortField] = Nil,
  variable: Seq[com.iofficecorp.jasperserver.pumped.report.Variable] = Nil,
  filterExpression: Option[com.iofficecorp.jasperserver.pumped.report.FilterExpression] = None,
  group: Seq[com.iofficecorp.jasperserver.pumped.report.Group] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_scriptletClass = attributes.get("@scriptletClass") map { _.as[String] }
  lazy val attr_resourceBundle = attributes.get("@resourceBundle") map { _.as[String] }
  lazy val attr_whenResourceMissingType = attributes("@whenResourceMissingType").as[WhenResourceMissingTypeType]
  lazy val attr_uuid = attributes.get("@uuid") map { _.as[String] }
}

      


case class Scriptlet(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  scriptletDescription: Option[com.iofficecorp.jasperserver.pumped.report.ScriptletDescription] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_class = attributes("@class").as[String]
}

      


case class ScriptletDescription(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait IsForPrompting

object IsForPrompting {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsForPrompting = value match {
    case "true" => TrueValue19
    case "false" => FalseValue19

  }
}

case object TrueValue19 extends IsForPrompting { override def toString = "true" }
case object FalseValue19 extends IsForPrompting { override def toString = "false" }


case class Parameter(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  parameterDescription: Option[com.iofficecorp.jasperserver.pumped.report.ParameterDescription] = None,
  defaultValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DefaultValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_class = attributes("@class").as[String]
  lazy val attr_nestedType = attributes.get("@nestedType") map { _.as[String] }
  lazy val attr_isForPrompting = attributes("@isForPrompting").as[IsForPrompting]
}

      


case class ParameterDescription(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class DefaultValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class QueryString(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_language = attributes("@language").as[String]
}

      


case class Field(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  fieldDescription: Option[com.iofficecorp.jasperserver.pumped.report.FieldDescription] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_class = attributes("@class").as[String]
}

      


case class FieldDescription(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait Order

object Order {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Order = value match {
    case "Ascending" => Ascending
    case "Descending" => Descending

  }
}

case object Ascending extends Order { override def toString = "Ascending" }
case object Descending extends Order { override def toString = "Descending" }

trait Type

object Type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Type = value match {
    case "Field" => FieldValue
    case "Variable" => VariableValue

  }
}

case object FieldValue extends Type { override def toString = "Field" }
case object VariableValue extends Type { override def toString = "Variable" }


case class SortField(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_order = attributes("@order").as[Order]
  lazy val attr_type = attributes("@type").as[Type]
}

      

trait ResetType

object ResetType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ResetType = value match {
    case "None" => NoneTypeValue7
    case "Report" => ReportValue2
    case "Page" => PageValue2
    case "Column" => ColumnValue2
    case "Group" => GroupValue3

  }
}

case object NoneTypeValue7 extends ResetType { override def toString = "None" }
case object ReportValue2 extends ResetType { override def toString = "Report" }
case object PageValue2 extends ResetType { override def toString = "Page" }
case object ColumnValue2 extends ResetType { override def toString = "Column" }
case object GroupValue3 extends ResetType { override def toString = "Group" }

trait IncrementType

object IncrementType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IncrementType = value match {
    case "None" => NoneTypeValue8
    case "Report" => ReportValue3
    case "Page" => PageValue3
    case "Column" => ColumnValue3
    case "Group" => GroupValue4

  }
}

case object NoneTypeValue8 extends IncrementType { override def toString = "None" }
case object ReportValue3 extends IncrementType { override def toString = "Report" }
case object PageValue3 extends IncrementType { override def toString = "Page" }
case object ColumnValue3 extends IncrementType { override def toString = "Column" }
case object GroupValue4 extends IncrementType { override def toString = "Group" }

trait Calculation

object Calculation {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Calculation = value match {
    case "Nothing" => NothingValue
    case "Count" => CountValue
    case "DistinctCount" => DistinctCountValue
    case "Sum" => SumValue
    case "Average" => AverageValue
    case "Lowest" => LowestValue
    case "Highest" => HighestValue
    case "StandardDeviation" => StandardDeviationValue
    case "Variance" => VarianceValue
    case "System" => System
    case "First" => FirstValue

  }
}

case object NothingValue extends Calculation { override def toString = "Nothing" }
case object CountValue extends Calculation { override def toString = "Count" }
case object DistinctCountValue extends Calculation { override def toString = "DistinctCount" }
case object SumValue extends Calculation { override def toString = "Sum" }
case object AverageValue extends Calculation { override def toString = "Average" }
case object LowestValue extends Calculation { override def toString = "Lowest" }
case object HighestValue extends Calculation { override def toString = "Highest" }
case object StandardDeviationValue extends Calculation { override def toString = "StandardDeviation" }
case object VarianceValue extends Calculation { override def toString = "Variance" }
case object System extends Calculation { override def toString = "System" }
case object FirstValue extends Calculation { override def toString = "First" }


case class Variable(variableExpression: Option[com.iofficecorp.jasperserver.pumped.report.VariableExpression] = None,
  initialValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.InitialValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_class = attributes("@class").as[String]
  lazy val attr_resetType = attributes("@resetType").as[ResetType]
  lazy val attr_resetGroup = attributes.get("@resetGroup") map { _.as[String] }
  lazy val attr_incrementType = attributes("@incrementType").as[IncrementType]
  lazy val attr_incrementGroup = attributes.get("@incrementGroup") map { _.as[String] }
  lazy val attr_calculation = attributes("@calculation").as[Calculation]
  lazy val attr_incrementerFactoryClass = attributes.get("@incrementerFactoryClass") map { _.as[String] }
}

      


case class VariableExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class InitialValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class FilterExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait IsStartNewColumn

object IsStartNewColumn {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsStartNewColumn = value match {
    case "true" => TrueValue20
    case "false" => FalseValue20

  }
}

case object TrueValue20 extends IsStartNewColumn { override def toString = "true" }
case object FalseValue20 extends IsStartNewColumn { override def toString = "false" }

trait IsStartNewPage

object IsStartNewPage {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsStartNewPage = value match {
    case "true" => TrueValue21
    case "false" => FalseValue21

  }
}

case object TrueValue21 extends IsStartNewPage { override def toString = "true" }
case object FalseValue21 extends IsStartNewPage { override def toString = "false" }

trait IsResetPageNumber

object IsResetPageNumber {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsResetPageNumber = value match {
    case "true" => TrueValue22
    case "false" => FalseValue22

  }
}

case object TrueValue22 extends IsResetPageNumber { override def toString = "true" }
case object FalseValue22 extends IsResetPageNumber { override def toString = "false" }

trait IsReprintHeaderOnEachPage

object IsReprintHeaderOnEachPage {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsReprintHeaderOnEachPage = value match {
    case "true" => TrueValue23
    case "false" => FalseValue23

  }
}

case object TrueValue23 extends IsReprintHeaderOnEachPage { override def toString = "true" }
case object FalseValue23 extends IsReprintHeaderOnEachPage { override def toString = "false" }

trait FooterPosition

object FooterPosition {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): FooterPosition = value match {
    case "Normal" => Normal
    case "StackAtBottom" => StackAtBottom
    case "ForceAtBottom" => ForceAtBottom
    case "CollateAtBottom" => CollateAtBottom

  }
}

case object Normal extends FooterPosition { override def toString = "Normal" }
case object StackAtBottom extends FooterPosition { override def toString = "StackAtBottom" }
case object ForceAtBottom extends FooterPosition { override def toString = "ForceAtBottom" }
case object CollateAtBottom extends FooterPosition { override def toString = "CollateAtBottom" }

trait KeepTogether

object KeepTogether {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): KeepTogether = value match {
    case "true" => TrueValue24
    case "false" => FalseValue24

  }
}

case object TrueValue24 extends KeepTogether { override def toString = "true" }
case object FalseValue24 extends KeepTogether { override def toString = "false" }


case class Group(groupExpression: Option[com.iofficecorp.jasperserver.pumped.report.GroupExpression] = None,
  groupHeader: Option[com.iofficecorp.jasperserver.pumped.report.GroupHeader] = None,
  groupFooter: Option[com.iofficecorp.jasperserver.pumped.report.GroupFooter] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_isStartNewColumn = attributes("@isStartNewColumn").as[IsStartNewColumn]
  lazy val attr_isStartNewPage = attributes("@isStartNewPage").as[IsStartNewPage]
  lazy val attr_isResetPageNumber = attributes("@isResetPageNumber").as[IsResetPageNumber]
  lazy val attr_isReprintHeaderOnEachPage = attributes("@isReprintHeaderOnEachPage").as[IsReprintHeaderOnEachPage]
  lazy val attr_minHeightToStartNewPage = attributes("@minHeightToStartNewPage").as[String]
  lazy val attr_footerPosition = attributes("@footerPosition").as[FooterPosition]
  lazy val attr_keepTogether = attributes("@keepTogether").as[KeepTogether]
}

      


case class GroupExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class GroupHeader(groupheaderoption: Seq[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.GroupHeaderOption]] = Nil)
      

trait GroupHeaderOption

case class GroupFooter(groupfooteroption: Seq[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.GroupFooterOption]] = Nil)
      

trait GroupFooterOption

case class Background(band: Option[com.iofficecorp.jasperserver.pumped.report.Band] = None)
      


case class Title(band: Option[com.iofficecorp.jasperserver.pumped.report.Band] = None)
      


case class PageHeader(band: Option[com.iofficecorp.jasperserver.pumped.report.Band] = None)
      


case class ColumnHeader(band: Option[com.iofficecorp.jasperserver.pumped.report.Band] = None)
      


case class Detail(detailoption: Seq[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.DetailOption]] = Nil)
      

trait DetailOption

case class ColumnFooter(band: Option[com.iofficecorp.jasperserver.pumped.report.Band] = None)
      


case class PageFooter(band: Option[com.iofficecorp.jasperserver.pumped.report.Band] = None)
      


case class LastPageFooter(band: Option[com.iofficecorp.jasperserver.pumped.report.Band] = None)
      


case class Summary(band: Option[com.iofficecorp.jasperserver.pumped.report.Band] = None)
      


case class NoData(band: Option[com.iofficecorp.jasperserver.pumped.report.Band] = None)
      

trait IsSplitAllowed

object IsSplitAllowed {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsSplitAllowed = value match {
    case "true" => TrueValue25
    case "false" => FalseValue25

  }
}

case object TrueValue25 extends IsSplitAllowed { override def toString = "true" }
case object FalseValue25 extends IsSplitAllowed { override def toString = "false" }

trait SplitType

object SplitType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): SplitType = value match {
    case "Stretch" => Stretch
    case "Prevent" => Prevent
    case "Immediate" => Immediate

  }
}

case object Stretch extends SplitType { override def toString = "Stretch" }
case object Prevent extends SplitType { override def toString = "Prevent" }
case object Immediate extends SplitType { override def toString = "Immediate" }


case class Band(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  printWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.PrintWhenExpression] = None,
  bandoption: Seq[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.BandOption]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends GroupHeaderOption with GroupFooterOption with DetailOption {
  lazy val attr_height = attributes("@height").as[String]
  lazy val attr_isSplitAllowed = attributes.get("@isSplitAllowed") map { _.as[IsSplitAllowed] }
  lazy val attr_splitType = attributes.get("@splitType") map { _.as[SplitType] }
}

      

trait BandOption
trait EvaluationTime

object EvaluationTime {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): EvaluationTime = value match {
    case "Now" => NowValue2
    case "Report" => ReportValue4
    case "Group" => GroupValue5

  }
}

case object NowValue2 extends EvaluationTime { override def toString = "Now" }
case object ReportValue4 extends EvaluationTime { override def toString = "Report" }
case object GroupValue5 extends EvaluationTime { override def toString = "Group" }


case class Part(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  printWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.PrintWhenExpression] = None,
  partNameExpression: Option[com.iofficecorp.jasperserver.pumped.report.PartNameExpression] = None,
  partComponent: com.iofficecorp.jasperserver.pumped.report.PartComponentType,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends GroupHeaderOption with GroupFooterOption with DetailOption {
  lazy val attr_uuid = attributes.get("@uuid") map { _.as[String] }
  lazy val attr_evaluationTime = attributes.get("@evaluationTime") map { _.as[EvaluationTime] }
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
}

      


case class PartNameExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


/** 
*/
case class PartComponentType()
      

trait TypeType

object TypeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TypeType = value match {
    case "Page" => PageValue4
    case "Column" => ColumnValue4

  }
}

case object PageValue4 extends TypeType { override def toString = "Page" }
case object ColumnValue4 extends TypeType { override def toString = "Column" }


case class Break(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BandOption with ElementGroupOption with FrameOption {
  lazy val attr_type = attributes("@type").as[TypeType]
}

      

trait Direction

object Direction {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Direction = value match {
    case "TopDown" => TopDown
    case "BottomUp" => BottomUp

  }
}

case object TopDown extends Direction { override def toString = "TopDown" }
case object BottomUp extends Direction { override def toString = "BottomUp" }


case class Line(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  graphicElement: Option[com.iofficecorp.jasperserver.pumped.report.GraphicElement] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BandOption with ElementGroupOption with CellContentsOption with FrameOption {
  lazy val attr_direction = attributes("@direction").as[Direction]
}

      

trait PositionType

object PositionType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): PositionType = value match {
    case "Float" => FloatType
    case "FixRelativeToTop" => FixRelativeToTop
    case "FixRelativeToBottom" => FixRelativeToBottom

  }
}

case object FloatType extends PositionType { override def toString = "Float" }
case object FixRelativeToTop extends PositionType { override def toString = "FixRelativeToTop" }
case object FixRelativeToBottom extends PositionType { override def toString = "FixRelativeToBottom" }

trait StretchType

object StretchType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): StretchType = value match {
    case "NoStretch" => NoStretch
    case "RelativeToTallestObject" => RelativeToTallestObject
    case "RelativeToBandHeight" => RelativeToBandHeight

  }
}

case object NoStretch extends StretchType { override def toString = "NoStretch" }
case object RelativeToTallestObject extends StretchType { override def toString = "RelativeToTallestObject" }
case object RelativeToBandHeight extends StretchType { override def toString = "RelativeToBandHeight" }

trait IsPrintRepeatedValues

object IsPrintRepeatedValues {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsPrintRepeatedValues = value match {
    case "true" => TrueValue26
    case "false" => FalseValue26

  }
}

case object TrueValue26 extends IsPrintRepeatedValues { override def toString = "true" }
case object FalseValue26 extends IsPrintRepeatedValues { override def toString = "false" }

trait ModeType

object ModeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ModeType = value match {
    case "Opaque" => OpaqueValue
    case "Transparent" => TransparentValue

  }
}

case object OpaqueValue extends ModeType { override def toString = "Opaque" }
case object TransparentValue extends ModeType { override def toString = "Transparent" }

trait IsRemoveLineWhenBlank

object IsRemoveLineWhenBlank {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsRemoveLineWhenBlank = value match {
    case "true" => TrueValue27
    case "false" => FalseValue27

  }
}

case object TrueValue27 extends IsRemoveLineWhenBlank { override def toString = "true" }
case object FalseValue27 extends IsRemoveLineWhenBlank { override def toString = "false" }

trait IsPrintInFirstWholeBand

object IsPrintInFirstWholeBand {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsPrintInFirstWholeBand = value match {
    case "true" => TrueValue28
    case "false" => FalseValue28

  }
}

case object TrueValue28 extends IsPrintInFirstWholeBand { override def toString = "true" }
case object FalseValue28 extends IsPrintInFirstWholeBand { override def toString = "false" }

trait IsPrintWhenDetailOverflows

object IsPrintWhenDetailOverflows {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsPrintWhenDetailOverflows = value match {
    case "true" => TrueValue29
    case "false" => FalseValue29

  }
}

case object TrueValue29 extends IsPrintWhenDetailOverflows { override def toString = "true" }
case object FalseValue29 extends IsPrintWhenDetailOverflows { override def toString = "false" }


case class ReportElement(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  propertyExpression: Seq[com.iofficecorp.jasperserver.pumped.report.PropertyExpression] = Nil,
  printWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.PrintWhenExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_uuid = attributes.get("@uuid") map { _.as[String] }
  lazy val attr_key = attributes.get("@key") map { _.as[String] }
  lazy val attr_style = attributes.get("@style") map { _.as[String] }
  lazy val attr_positionType = attributes("@positionType").as[PositionType]
  lazy val attr_stretchType = attributes("@stretchType").as[StretchType]
  lazy val attr_isPrintRepeatedValues = attributes("@isPrintRepeatedValues").as[IsPrintRepeatedValues]
  lazy val attr_mode = attributes.get("@mode") map { _.as[ModeType] }
  lazy val attr_x = attributes("@x").as[String]
  lazy val attr_y = attributes("@y").as[String]
  lazy val attr_width = attributes("@width").as[String]
  lazy val attr_height = attributes("@height").as[String]
  lazy val attr_isRemoveLineWhenBlank = attributes("@isRemoveLineWhenBlank").as[IsRemoveLineWhenBlank]
  lazy val attr_isPrintInFirstWholeBand = attributes("@isPrintInFirstWholeBand").as[IsPrintInFirstWholeBand]
  lazy val attr_isPrintWhenDetailOverflows = attributes("@isPrintWhenDetailOverflows").as[IsPrintWhenDetailOverflows]
  lazy val attr_printWhenGroupChanges = attributes.get("@printWhenGroupChanges") map { _.as[String] }
  lazy val attr_forecolor = attributes.get("@forecolor") map { _.as[String] }
  lazy val attr_backcolor = attributes.get("@backcolor") map { _.as[String] }
}

      


case class PrintWhenExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait StretchTypeType

object StretchTypeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): StretchTypeType = value match {
    case "NoStretch" => NoStretchValue
    case "RelativeToTallestObject" => RelativeToTallestObjectValue
    case "RelativeToBandHeight" => RelativeToBandHeightValue

  }
}

case object NoStretchValue extends StretchTypeType { override def toString = "NoStretch" }
case object RelativeToTallestObjectValue extends StretchTypeType { override def toString = "RelativeToTallestObject" }
case object RelativeToBandHeightValue extends StretchTypeType { override def toString = "RelativeToBandHeight" }

trait PenType2

object PenType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): PenType2 = value match {
    case "None" => NoneTypeValue9
    case "Thin" => ThinValue6
    case "1Point" => Number1PointValue6
    case "2Point" => Number2PointValue6
    case "4Point" => Number4PointValue6
    case "Dotted" => DottedValue7

  }
}

case object NoneTypeValue9 extends PenType2 { override def toString = "None" }
case object ThinValue6 extends PenType2 { override def toString = "Thin" }
case object Number1PointValue6 extends PenType2 { override def toString = "1Point" }
case object Number2PointValue6 extends PenType2 { override def toString = "2Point" }
case object Number4PointValue6 extends PenType2 { override def toString = "4Point" }
case object DottedValue7 extends PenType2 { override def toString = "Dotted" }

trait FillType

object FillType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): FillType = value match {
    case "Solid" => SolidValue2

  }
}

case object SolidValue2 extends FillType { override def toString = "Solid" }


case class GraphicElement(pen: Option[com.iofficecorp.jasperserver.pumped.report.Pen] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_stretchType = attributes.get("@stretchType") map { _.as[StretchTypeType] }
  lazy val attr_pen = attributes.get("@pen") map { _.as[PenType2] }
  lazy val attr_fill = attributes.get("@fill") map { _.as[FillType] }
}

      


case class Rectangle(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  graphicElement: Option[com.iofficecorp.jasperserver.pumped.report.GraphicElement] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BandOption with ElementGroupOption with CellContentsOption with FrameOption {
  lazy val attr_radius = attributes.get("@radius") map { _.as[String] }
}

      


case class Ellipse(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  graphicElement: Option[com.iofficecorp.jasperserver.pumped.report.GraphicElement] = None) extends BandOption with ElementGroupOption with CellContentsOption with FrameOption
      

trait ScaleImageType

object ScaleImageType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ScaleImageType = value match {
    case "Clip" => ClipValue
    case "FillFrame" => FillFrameValue
    case "RetainShape" => RetainShapeValue
    case "RealHeight" => RealHeightValue
    case "RealSize" => RealSizeValue

  }
}

case object ClipValue extends ScaleImageType { override def toString = "Clip" }
case object FillFrameValue extends ScaleImageType { override def toString = "FillFrame" }
case object RetainShapeValue extends ScaleImageType { override def toString = "RetainShape" }
case object RealHeightValue extends ScaleImageType { override def toString = "RealHeight" }
case object RealSizeValue extends ScaleImageType { override def toString = "RealSize" }

trait HAlignType

object HAlignType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): HAlignType = value match {
    case "Left" => LeftTypeValue5
    case "Center" => CenterValue4
    case "Right" => RightTypeValue5

  }
}

case object LeftTypeValue5 extends HAlignType { override def toString = "Left" }
case object CenterValue4 extends HAlignType { override def toString = "Center" }
case object RightTypeValue5 extends HAlignType { override def toString = "Right" }

trait VAlignType

object VAlignType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): VAlignType = value match {
    case "Top" => TopValue3
    case "Middle" => MiddleValue3
    case "Bottom" => BottomValue3

  }
}

case object TopValue3 extends VAlignType { override def toString = "Top" }
case object MiddleValue3 extends VAlignType { override def toString = "Middle" }
case object BottomValue3 extends VAlignType { override def toString = "Bottom" }

trait IsUsingCache

object IsUsingCache {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsUsingCache = value match {
    case "true" => TrueValue30
    case "false" => FalseValue30

  }
}

case object TrueValue30 extends IsUsingCache { override def toString = "true" }
case object FalseValue30 extends IsUsingCache { override def toString = "false" }

trait IsLazy

object IsLazy {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsLazy = value match {
    case "true" => TrueValue31
    case "false" => FalseValue31

  }
}

case object TrueValue31 extends IsLazy { override def toString = "true" }
case object FalseValue31 extends IsLazy { override def toString = "false" }

trait OnErrorType

object OnErrorType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): OnErrorType = value match {
    case "Error" => ErrorValue2
    case "Blank" => Blank
    case "Icon" => Icon

  }
}

case object ErrorValue2 extends OnErrorType { override def toString = "Error" }
case object Blank extends OnErrorType { override def toString = "Blank" }
case object Icon extends OnErrorType { override def toString = "Icon" }


case class Image(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  box: Option[com.iofficecorp.jasperserver.pumped.report.Box] = None,
  graphicElement: Option[com.iofficecorp.jasperserver.pumped.report.GraphicElement] = None,
  imageExpression: Option[com.iofficecorp.jasperserver.pumped.report.ImageExpression] = None,
  anchorNameExpression: Option[com.iofficecorp.jasperserver.pumped.report.AnchorNameExpression] = None,
  hyperlinkReferenceExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkReferenceExpression] = None,
  hyperlinkWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkWhenExpression] = None,
  hyperlinkAnchorExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkAnchorExpression] = None,
  hyperlinkPageExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkPageExpression] = None,
  hyperlinkTooltipExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkTooltipExpression] = None,
  hyperlinkParameter: Seq[com.iofficecorp.jasperserver.pumped.report.HyperlinkParameter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BandOption with ElementGroupOption with CellContentsOption with FrameOption {
  lazy val attr_scaleImage = attributes.get("@scaleImage") map { _.as[ScaleImageType] }
  lazy val attr_hAlign = attributes.get("@hAlign") map { _.as[HAlignType] }
  lazy val attr_vAlign = attributes.get("@vAlign") map { _.as[VAlignType] }
  lazy val attr_isUsingCache = attributes.get("@isUsingCache") map { _.as[IsUsingCache] }
  lazy val attr_isLazy = attributes("@isLazy").as[IsLazy]
  lazy val attr_onErrorType = attributes("@onErrorType").as[OnErrorType]
  lazy val attr_evaluationTime = attributes("@evaluationTime").as[ComplexEvaluationTime]
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_hyperlinkType = attributes.get("@hyperlinkType") map { _.as[String] }
  lazy val attr_hyperlinkTarget = attributes.get("@hyperlinkTarget") map { _.as[String] }
  lazy val attr_bookmarkLevel = attributes("@bookmarkLevel").as[String]
}

      


case class ImageExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_class = attributes("@class").as[String]
}

      

trait BorderType

object BorderType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): BorderType = value match {
    case "None" => NoneTypeValue10
    case "Thin" => ThinValue7
    case "1Point" => Number1PointValue7
    case "2Point" => Number2PointValue7
    case "4Point" => Number4PointValue7
    case "Dotted" => DottedValue8

  }
}

case object NoneTypeValue10 extends BorderType { override def toString = "None" }
case object ThinValue7 extends BorderType { override def toString = "Thin" }
case object Number1PointValue7 extends BorderType { override def toString = "1Point" }
case object Number2PointValue7 extends BorderType { override def toString = "2Point" }
case object Number4PointValue7 extends BorderType { override def toString = "4Point" }
case object DottedValue8 extends BorderType { override def toString = "Dotted" }

trait TopBorderType

object TopBorderType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TopBorderType = value match {
    case "None" => NoneTypeValue11
    case "Thin" => ThinValue8
    case "1Point" => Number1PointValue8
    case "2Point" => Number2PointValue8
    case "4Point" => Number4PointValue8
    case "Dotted" => DottedValue9

  }
}

case object NoneTypeValue11 extends TopBorderType { override def toString = "None" }
case object ThinValue8 extends TopBorderType { override def toString = "Thin" }
case object Number1PointValue8 extends TopBorderType { override def toString = "1Point" }
case object Number2PointValue8 extends TopBorderType { override def toString = "2Point" }
case object Number4PointValue8 extends TopBorderType { override def toString = "4Point" }
case object DottedValue9 extends TopBorderType { override def toString = "Dotted" }

trait LeftBorderType

object LeftBorderType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): LeftBorderType = value match {
    case "None" => NoneTypeValue12
    case "Thin" => ThinValue9
    case "1Point" => Number1PointValue9
    case "2Point" => Number2PointValue9
    case "4Point" => Number4PointValue9
    case "Dotted" => DottedValue10

  }
}

case object NoneTypeValue12 extends LeftBorderType { override def toString = "None" }
case object ThinValue9 extends LeftBorderType { override def toString = "Thin" }
case object Number1PointValue9 extends LeftBorderType { override def toString = "1Point" }
case object Number2PointValue9 extends LeftBorderType { override def toString = "2Point" }
case object Number4PointValue9 extends LeftBorderType { override def toString = "4Point" }
case object DottedValue10 extends LeftBorderType { override def toString = "Dotted" }

trait BottomBorderType

object BottomBorderType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): BottomBorderType = value match {
    case "None" => NoneTypeValue13
    case "Thin" => ThinValue10
    case "1Point" => Number1PointValue10
    case "2Point" => Number2PointValue10
    case "4Point" => Number4PointValue10
    case "Dotted" => DottedValue11

  }
}

case object NoneTypeValue13 extends BottomBorderType { override def toString = "None" }
case object ThinValue10 extends BottomBorderType { override def toString = "Thin" }
case object Number1PointValue10 extends BottomBorderType { override def toString = "1Point" }
case object Number2PointValue10 extends BottomBorderType { override def toString = "2Point" }
case object Number4PointValue10 extends BottomBorderType { override def toString = "4Point" }
case object DottedValue11 extends BottomBorderType { override def toString = "Dotted" }

trait RightBorderType

object RightBorderType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): RightBorderType = value match {
    case "None" => NoneTypeValue14
    case "Thin" => ThinValue11
    case "1Point" => Number1PointValue11
    case "2Point" => Number2PointValue11
    case "4Point" => Number4PointValue11
    case "Dotted" => DottedValue12

  }
}

case object NoneTypeValue14 extends RightBorderType { override def toString = "None" }
case object ThinValue11 extends RightBorderType { override def toString = "Thin" }
case object Number1PointValue11 extends RightBorderType { override def toString = "1Point" }
case object Number2PointValue11 extends RightBorderType { override def toString = "2Point" }
case object Number4PointValue11 extends RightBorderType { override def toString = "4Point" }
case object DottedValue12 extends RightBorderType { override def toString = "Dotted" }


case class Box(pen: Option[com.iofficecorp.jasperserver.pumped.report.Pen] = None,
  topPen: Option[com.iofficecorp.jasperserver.pumped.report.TopPen] = None,
  leftPen: Option[com.iofficecorp.jasperserver.pumped.report.LeftPen] = None,
  bottomPen: Option[com.iofficecorp.jasperserver.pumped.report.BottomPen] = None,
  rightPen: Option[com.iofficecorp.jasperserver.pumped.report.RightPen] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_border = attributes.get("@border") map { _.as[BorderType] }
  lazy val attr_borderColor = attributes.get("@borderColor") map { _.as[String] }
  lazy val attr_padding = attributes.get("@padding") map { _.as[String] }
  lazy val attr_topBorder = attributes.get("@topBorder") map { _.as[TopBorderType] }
  lazy val attr_topBorderColor = attributes.get("@topBorderColor") map { _.as[String] }
  lazy val attr_topPadding = attributes.get("@topPadding") map { _.as[String] }
  lazy val attr_leftBorder = attributes.get("@leftBorder") map { _.as[LeftBorderType] }
  lazy val attr_leftBorderColor = attributes.get("@leftBorderColor") map { _.as[String] }
  lazy val attr_leftPadding = attributes.get("@leftPadding") map { _.as[String] }
  lazy val attr_bottomBorder = attributes.get("@bottomBorder") map { _.as[BottomBorderType] }
  lazy val attr_bottomBorderColor = attributes.get("@bottomBorderColor") map { _.as[String] }
  lazy val attr_bottomPadding = attributes.get("@bottomPadding") map { _.as[String] }
  lazy val attr_rightBorder = attributes.get("@rightBorder") map { _.as[RightBorderType] }
  lazy val attr_rightBorderColor = attributes.get("@rightBorderColor") map { _.as[String] }
  lazy val attr_rightPadding = attributes.get("@rightPadding") map { _.as[String] }
}

      

trait LineStyleType

object LineStyleType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): LineStyleType = value match {
    case "Solid" => SolidValue3
    case "Dashed" => DashedValue
    case "Dotted" => DottedValue13
    case "Double" => DoubleTypeValue3

  }
}

case object SolidValue3 extends LineStyleType { override def toString = "Solid" }
case object DashedValue extends LineStyleType { override def toString = "Dashed" }
case object DottedValue13 extends LineStyleType { override def toString = "Dotted" }
case object DoubleTypeValue3 extends LineStyleType { override def toString = "Double" }


case class TopPen(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_lineWidth = attributes.get("@lineWidth") map { _.as[String] }
  lazy val attr_lineStyle = attributes.get("@lineStyle") map { _.as[LineStyleType] }
  lazy val attr_lineColor = attributes.get("@lineColor") map { _.as[String] }
}

      

trait LineStyleType2

object LineStyleType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): LineStyleType2 = value match {
    case "Solid" => SolidValue4
    case "Dashed" => DashedValue2
    case "Dotted" => DottedValue14
    case "Double" => DoubleTypeValue4

  }
}

case object SolidValue4 extends LineStyleType2 { override def toString = "Solid" }
case object DashedValue2 extends LineStyleType2 { override def toString = "Dashed" }
case object DottedValue14 extends LineStyleType2 { override def toString = "Dotted" }
case object DoubleTypeValue4 extends LineStyleType2 { override def toString = "Double" }


case class LeftPen(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_lineWidth = attributes.get("@lineWidth") map { _.as[String] }
  lazy val attr_lineStyle = attributes.get("@lineStyle") map { _.as[LineStyleType2] }
  lazy val attr_lineColor = attributes.get("@lineColor") map { _.as[String] }
}

      

trait LineStyleType3

object LineStyleType3 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): LineStyleType3 = value match {
    case "Solid" => SolidValue5
    case "Dashed" => DashedValue3
    case "Dotted" => DottedValue15
    case "Double" => DoubleTypeValue5

  }
}

case object SolidValue5 extends LineStyleType3 { override def toString = "Solid" }
case object DashedValue3 extends LineStyleType3 { override def toString = "Dashed" }
case object DottedValue15 extends LineStyleType3 { override def toString = "Dotted" }
case object DoubleTypeValue5 extends LineStyleType3 { override def toString = "Double" }


case class BottomPen(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_lineWidth = attributes.get("@lineWidth") map { _.as[String] }
  lazy val attr_lineStyle = attributes.get("@lineStyle") map { _.as[LineStyleType3] }
  lazy val attr_lineColor = attributes.get("@lineColor") map { _.as[String] }
}

      

trait LineStyleType4

object LineStyleType4 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): LineStyleType4 = value match {
    case "Solid" => SolidValue6
    case "Dashed" => DashedValue4
    case "Dotted" => DottedValue16
    case "Double" => DoubleTypeValue6

  }
}

case object SolidValue6 extends LineStyleType4 { override def toString = "Solid" }
case object DashedValue4 extends LineStyleType4 { override def toString = "Dashed" }
case object DottedValue16 extends LineStyleType4 { override def toString = "Dotted" }
case object DoubleTypeValue6 extends LineStyleType4 { override def toString = "Double" }


case class RightPen(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_lineWidth = attributes.get("@lineWidth") map { _.as[String] }
  lazy val attr_lineStyle = attributes.get("@lineStyle") map { _.as[LineStyleType4] }
  lazy val attr_lineColor = attributes.get("@lineColor") map { _.as[String] }
}

      


case class AnchorNameExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class HyperlinkReferenceExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class HyperlinkWhenExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class HyperlinkAnchorExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class HyperlinkPageExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class HyperlinkTooltipExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class HyperlinkParameter(hyperlinkParameterExpression: com.iofficecorp.jasperserver.pumped.report.HyperlinkParameterExpression,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
}

      


case class HyperlinkParameterExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_class = attributes("@class").as[String]
}

      


case class StaticText(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  box: Option[com.iofficecorp.jasperserver.pumped.report.Box] = None,
  textElement: Option[com.iofficecorp.jasperserver.pumped.report.TextElement] = None,
  text: Option[com.iofficecorp.jasperserver.pumped.report.Text] = None) extends BandOption with ElementGroupOption with CellContentsOption with FrameOption
      


case class Text(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait TextAlignment

object TextAlignment {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TextAlignment = value match {
    case "Left" => LeftTypeValue6
    case "Center" => CenterValue5
    case "Right" => RightTypeValue6
    case "Justified" => JustifiedValue2

  }
}

case object LeftTypeValue6 extends TextAlignment { override def toString = "Left" }
case object CenterValue5 extends TextAlignment { override def toString = "Center" }
case object RightTypeValue6 extends TextAlignment { override def toString = "Right" }
case object JustifiedValue2 extends TextAlignment { override def toString = "Justified" }

trait VerticalAlignment

object VerticalAlignment {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): VerticalAlignment = value match {
    case "Top" => TopValue4
    case "Middle" => MiddleValue4
    case "Bottom" => BottomValue4

  }
}

case object TopValue4 extends VerticalAlignment { override def toString = "Top" }
case object MiddleValue4 extends VerticalAlignment { override def toString = "Middle" }
case object BottomValue4 extends VerticalAlignment { override def toString = "Bottom" }

trait RotationType

object RotationType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): RotationType = value match {
    case "None" => NoneTypeValue15
    case "Left" => LeftTypeValue7
    case "Right" => RightTypeValue7
    case "UpsideDown" => UpsideDownValue

  }
}

case object NoneTypeValue15 extends RotationType { override def toString = "None" }
case object LeftTypeValue7 extends RotationType { override def toString = "Left" }
case object RightTypeValue7 extends RotationType { override def toString = "Right" }
case object UpsideDownValue extends RotationType { override def toString = "UpsideDown" }

trait LineSpacingType2

object LineSpacingType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): LineSpacingType2 = value match {
    case "Single" => SingleValue2
    case "1_1_2" => Number1_1_2Value2
    case "Double" => DoubleTypeValue7

  }
}

case object SingleValue2 extends LineSpacingType2 { override def toString = "Single" }
case object Number1_1_2Value2 extends LineSpacingType2 { override def toString = "1_1_2" }
case object DoubleTypeValue7 extends LineSpacingType2 { override def toString = "Double" }

trait IsStyledTextType

object IsStyledTextType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsStyledTextType = value match {
    case "true" => TrueValue32
    case "false" => FalseValue32

  }
}

case object TrueValue32 extends IsStyledTextType { override def toString = "true" }
case object FalseValue32 extends IsStyledTextType { override def toString = "false" }


case class TextElement(font: Option[com.iofficecorp.jasperserver.pumped.report.Font] = None,
  paragraph: Option[com.iofficecorp.jasperserver.pumped.report.Paragraph] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_textAlignment = attributes.get("@textAlignment") map { _.as[TextAlignment] }
  lazy val attr_verticalAlignment = attributes.get("@verticalAlignment") map { _.as[VerticalAlignment] }
  lazy val attr_rotation = attributes.get("@rotation") map { _.as[RotationType] }
  lazy val attr_lineSpacing = attributes.get("@lineSpacing") map { _.as[LineSpacingType2] }
  lazy val attr_isStyledText = attributes.get("@isStyledText") map { _.as[IsStyledTextType] }
  lazy val attr_markup = attributes.get("@markup") map { _.as[String] }
}

      

trait IsBoldType2

object IsBoldType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsBoldType2 = value match {
    case "true" => TrueValue33
    case "false" => FalseValue33

  }
}

case object TrueValue33 extends IsBoldType2 { override def toString = "true" }
case object FalseValue33 extends IsBoldType2 { override def toString = "false" }

trait IsItalicType2

object IsItalicType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsItalicType2 = value match {
    case "true" => TrueValue34
    case "false" => FalseValue34

  }
}

case object TrueValue34 extends IsItalicType2 { override def toString = "true" }
case object FalseValue34 extends IsItalicType2 { override def toString = "false" }

trait IsUnderlineType2

object IsUnderlineType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsUnderlineType2 = value match {
    case "true" => TrueValue35
    case "false" => FalseValue35

  }
}

case object TrueValue35 extends IsUnderlineType2 { override def toString = "true" }
case object FalseValue35 extends IsUnderlineType2 { override def toString = "false" }

trait IsStrikeThroughType2

object IsStrikeThroughType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsStrikeThroughType2 = value match {
    case "true" => TrueValue36
    case "false" => FalseValue36

  }
}

case object TrueValue36 extends IsStrikeThroughType2 { override def toString = "true" }
case object FalseValue36 extends IsStrikeThroughType2 { override def toString = "false" }

trait IsPdfEmbeddedType2

object IsPdfEmbeddedType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsPdfEmbeddedType2 = value match {
    case "true" => TrueValue37
    case "false" => FalseValue37

  }
}

case object TrueValue37 extends IsPdfEmbeddedType2 { override def toString = "true" }
case object FalseValue37 extends IsPdfEmbeddedType2 { override def toString = "false" }


case class Font(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_reportFont = attributes.get("@reportFont") map { _.as[String] }
  lazy val attr_fontName = attributes.get("@fontName") map { _.as[String] }
  lazy val attr_size = attributes.get("@size") map { _.as[String] }
  lazy val attr_isBold = attributes.get("@isBold") map { _.as[IsBoldType2] }
  lazy val attr_isItalic = attributes.get("@isItalic") map { _.as[IsItalicType2] }
  lazy val attr_isUnderline = attributes.get("@isUnderline") map { _.as[IsUnderlineType2] }
  lazy val attr_isStrikeThrough = attributes.get("@isStrikeThrough") map { _.as[IsStrikeThroughType2] }
  lazy val attr_pdfFontName = attributes.get("@pdfFontName") map { _.as[String] }
  lazy val attr_pdfEncoding = attributes.get("@pdfEncoding") map { _.as[String] }
  lazy val attr_isPdfEmbedded = attributes.get("@isPdfEmbedded") map { _.as[IsPdfEmbeddedType2] }
}

      

trait IsStretchWithOverflow

object IsStretchWithOverflow {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsStretchWithOverflow = value match {
    case "true" => TrueValue38
    case "false" => FalseValue38

  }
}

case object TrueValue38 extends IsStretchWithOverflow { override def toString = "true" }
case object FalseValue38 extends IsStretchWithOverflow { override def toString = "false" }

trait IsBlankWhenNullType

object IsBlankWhenNullType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsBlankWhenNullType = value match {
    case "true" => TrueValue39
    case "false" => FalseValue39

  }
}

case object TrueValue39 extends IsBlankWhenNullType { override def toString = "true" }
case object FalseValue39 extends IsBlankWhenNullType { override def toString = "false" }


case class TextField(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  box: Option[com.iofficecorp.jasperserver.pumped.report.Box] = None,
  textElement: Option[com.iofficecorp.jasperserver.pumped.report.TextElement] = None,
  textFieldExpression: Option[com.iofficecorp.jasperserver.pumped.report.TextFieldExpression] = None,
  patternExpression: Option[scalaxb.DataRecord[Any]] = None,
  anchorNameExpression: Option[com.iofficecorp.jasperserver.pumped.report.AnchorNameExpression] = None,
  hyperlinkReferenceExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkReferenceExpression] = None,
  hyperlinkWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkWhenExpression] = None,
  hyperlinkAnchorExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkAnchorExpression] = None,
  hyperlinkPageExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkPageExpression] = None,
  hyperlinkTooltipExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkTooltipExpression] = None,
  hyperlinkParameter: Seq[com.iofficecorp.jasperserver.pumped.report.HyperlinkParameter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BandOption with ElementGroupOption with CellContentsOption with FrameOption {
  lazy val attr_isStretchWithOverflow = attributes("@isStretchWithOverflow").as[IsStretchWithOverflow]
  lazy val attr_evaluationTime = attributes("@evaluationTime").as[ComplexEvaluationTime]
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_pattern = attributes.get("@pattern") map { _.as[String] }
  lazy val attr_isBlankWhenNull = attributes.get("@isBlankWhenNull") map { _.as[IsBlankWhenNullType] }
  lazy val attr_hyperlinkType = attributes.get("@hyperlinkType") map { _.as[String] }
  lazy val attr_hyperlinkTarget = attributes.get("@hyperlinkTarget") map { _.as[String] }
  lazy val attr_bookmarkLevel = attributes("@bookmarkLevel").as[String]
}

      


case class TextFieldExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_class = attributes.get("@class") map { _.as[String] }
}

      

trait IsUsingCacheType

object IsUsingCacheType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsUsingCacheType = value match {
    case "true" => TrueValue40
    case "false" => FalseValue40

  }
}

case object TrueValue40 extends IsUsingCacheType { override def toString = "true" }
case object FalseValue40 extends IsUsingCacheType { override def toString = "false" }

trait RunToBottom

object RunToBottom {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): RunToBottom = value match {
    case "true" => TrueValue41
    case "false" => FalseValue41

  }
}

case object TrueValue41 extends RunToBottom { override def toString = "true" }
case object FalseValue41 extends RunToBottom { override def toString = "false" }

trait OverflowType

object OverflowType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): OverflowType = value match {
    case "Stretch" => StretchValue
    case "NoStretch" => NoStretchValue2

  }
}

case object StretchValue extends OverflowType { override def toString = "Stretch" }
case object NoStretchValue2 extends OverflowType { override def toString = "NoStretch" }


case class Subreport(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  parametersMapExpression: Option[com.iofficecorp.jasperserver.pumped.report.ParametersMapExpression] = None,
  subreportParameter: Seq[com.iofficecorp.jasperserver.pumped.report.SubreportParameter] = Nil,
  subreportoption: Option[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.SubreportOption]] = None,
  returnValue: Seq[com.iofficecorp.jasperserver.pumped.report.ReturnValue] = Nil,
  subreportExpression: Option[com.iofficecorp.jasperserver.pumped.report.SubreportExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BandOption with ElementGroupOption with CellContentsOption with FrameOption {
  lazy val attr_isUsingCache = attributes.get("@isUsingCache") map { _.as[IsUsingCacheType] }
  lazy val attr_runToBottom = attributes.get("@runToBottom") map { _.as[RunToBottom] }
  lazy val attr_overflowType = attributes.get("@overflowType") map { _.as[OverflowType] }
}

      

trait SubreportOption

case class ParametersMapExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class SubreportParameter(subreportParameterExpression: Option[com.iofficecorp.jasperserver.pumped.report.SubreportParameterExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
}

      


case class SubreportParameterExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait CalculationType

object CalculationType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): CalculationType = value match {
    case "Nothing" => NothingValue2
    case "Count" => CountValue2
    case "DistinctCount" => DistinctCountValue2
    case "Sum" => SumValue2
    case "Average" => AverageValue2
    case "Lowest" => LowestValue2
    case "Highest" => HighestValue2
    case "StandardDeviation" => StandardDeviationValue2
    case "Variance" => VarianceValue2
    case "First" => FirstValue2

  }
}

case object NothingValue2 extends CalculationType { override def toString = "Nothing" }
case object CountValue2 extends CalculationType { override def toString = "Count" }
case object DistinctCountValue2 extends CalculationType { override def toString = "DistinctCount" }
case object SumValue2 extends CalculationType { override def toString = "Sum" }
case object AverageValue2 extends CalculationType { override def toString = "Average" }
case object LowestValue2 extends CalculationType { override def toString = "Lowest" }
case object HighestValue2 extends CalculationType { override def toString = "Highest" }
case object StandardDeviationValue2 extends CalculationType { override def toString = "StandardDeviation" }
case object VarianceValue2 extends CalculationType { override def toString = "Variance" }
case object FirstValue2 extends CalculationType { override def toString = "First" }


case class ReturnValue(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_subreportVariable = attributes.get("@subreportVariable") map { _.as[String] }
  lazy val attr_toVariable = attributes.get("@toVariable") map { _.as[String] }
  lazy val attr_calculation = attributes("@calculation").as[CalculationType]
  lazy val attr_incrementerFactoryClass = attributes.get("@incrementerFactoryClass") map { _.as[String] }
}

      


case class ConnectionExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil) extends SubreportOption with DatasetRunOption
      


case class DataSourceExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil) extends SubreportOption with DatasetRunOption
      


case class SubreportExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_class = attributes.get("@class") map { _.as[String] }
}

      


case class ElementGroup(elementgroupoption: Seq[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.ElementGroupOption]] = Nil) extends BandOption with ElementGroupOption with CellContentsOption with FrameOption
      

trait ElementGroupOption
trait IsShowLegend

object IsShowLegend {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowLegend = value match {
    case "true" => TrueValue42
    case "false" => FalseValue42

  }
}

case object TrueValue42 extends IsShowLegend { override def toString = "true" }
case object FalseValue42 extends IsShowLegend { override def toString = "false" }


case class Chart(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  box: Option[com.iofficecorp.jasperserver.pumped.report.Box] = None,
  chartTitle: Option[com.iofficecorp.jasperserver.pumped.report.ChartTitle] = None,
  chartSubtitle: Option[com.iofficecorp.jasperserver.pumped.report.ChartSubtitle] = None,
  chartLegend: Option[com.iofficecorp.jasperserver.pumped.report.ChartLegend] = None,
  anchorNameExpression: Option[com.iofficecorp.jasperserver.pumped.report.AnchorNameExpression] = None,
  hyperlinkReferenceExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkReferenceExpression] = None,
  hyperlinkWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkWhenExpression] = None,
  hyperlinkAnchorExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkAnchorExpression] = None,
  hyperlinkPageExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkPageExpression] = None,
  hyperlinkTooltipExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkTooltipExpression] = None,
  hyperlinkParameter: Seq[com.iofficecorp.jasperserver.pumped.report.HyperlinkParameter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isShowLegend = attributes.get("@isShowLegend") map { _.as[IsShowLegend] }
  lazy val attr_evaluationTime = attributes("@evaluationTime").as[BasicEvaluationTime]
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
  lazy val attr_hyperlinkType = attributes.get("@hyperlinkType") map { _.as[String] }
  lazy val attr_hyperlinkTarget = attributes.get("@hyperlinkTarget") map { _.as[String] }
  lazy val attr_bookmarkLevel = attributes("@bookmarkLevel").as[String]
  lazy val attr_customizerClass = attributes.get("@customizerClass") map { _.as[String] }
  lazy val attr_renderType = attributes.get("@renderType") map { _.as[String] }
  lazy val attr_theme = attributes.get("@theme") map { _.as[String] }
}

      

trait Position

object Position {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Position = value match {
    case "Top" => TopValue5
    case "Bottom" => BottomValue5
    case "Left" => LeftTypeValue8
    case "Right" => RightTypeValue8

  }
}

case object TopValue5 extends Position { override def toString = "Top" }
case object BottomValue5 extends Position { override def toString = "Bottom" }
case object LeftTypeValue8 extends Position { override def toString = "Left" }
case object RightTypeValue8 extends Position { override def toString = "Right" }


case class ChartTitle(font: Option[com.iofficecorp.jasperserver.pumped.report.Font] = None,
  titleExpression: Option[com.iofficecorp.jasperserver.pumped.report.TitleExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_position = attributes.get("@position") map { _.as[Position] }
  lazy val attr_color = attributes.get("@color") map { _.as[String] }
}

      


case class TitleExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class ChartSubtitle(font: Option[com.iofficecorp.jasperserver.pumped.report.Font] = None,
  subtitleExpression: Option[com.iofficecorp.jasperserver.pumped.report.SubtitleExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_color = attributes.get("@color") map { _.as[String] }
}

      


case class SubtitleExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait PositionType2

object PositionType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): PositionType2 = value match {
    case "Top" => TopValue6
    case "Bottom" => BottomValue6
    case "Left" => LeftTypeValue9
    case "Right" => RightTypeValue9

  }
}

case object TopValue6 extends PositionType2 { override def toString = "Top" }
case object BottomValue6 extends PositionType2 { override def toString = "Bottom" }
case object LeftTypeValue9 extends PositionType2 { override def toString = "Left" }
case object RightTypeValue9 extends PositionType2 { override def toString = "Right" }


case class ChartLegend(font: Option[com.iofficecorp.jasperserver.pumped.report.Font] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_textColor = attributes.get("@textColor") map { _.as[String] }
  lazy val attr_backgroundColor = attributes.get("@backgroundColor") map { _.as[String] }
  lazy val attr_position = attributes.get("@position") map { _.as[PositionType2] }
}

      


case class ItemLabel(font: Option[com.iofficecorp.jasperserver.pumped.report.Font] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_color = attributes.get("@color") map { _.as[String] }
  lazy val attr_backgroundColor = attributes.get("@backgroundColor") map { _.as[String] }
}

      


case class PieChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  pieDataset: com.iofficecorp.jasperserver.pumped.report.PieDataset,
  piePlot: com.iofficecorp.jasperserver.pumped.report.PiePlot) extends BandOption with ElementGroupOption with FrameOption
      


case class PieDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  pieSeries: Seq[com.iofficecorp.jasperserver.pumped.report.PieSeries] = Nil,
  keyExpression: Option[com.iofficecorp.jasperserver.pumped.report.KeyExpression] = None,
  valueExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueExpression] = None,
  labelExpression: Option[com.iofficecorp.jasperserver.pumped.report.LabelExpression] = None,
  sectionHyperlink: Option[com.iofficecorp.jasperserver.pumped.report.SectionHyperlink] = None,
  otherKeyExpression: Option[com.iofficecorp.jasperserver.pumped.report.OtherKeyExpression] = None,
  otherLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.OtherLabelExpression] = None,
  otherSectionHyperlink: Option[com.iofficecorp.jasperserver.pumped.report.OtherSectionHyperlink] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_minPercentage = attributes.get("@minPercentage") map { _.as[String] }
  lazy val attr_maxCount = attributes.get("@maxCount") map { _.as[String] }
}

      


case class PieSeries(keyExpression: Option[com.iofficecorp.jasperserver.pumped.report.KeyExpression] = None,
  valueExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueExpression] = None,
  labelExpression: Option[com.iofficecorp.jasperserver.pumped.report.LabelExpression] = None,
  sectionHyperlink: Option[com.iofficecorp.jasperserver.pumped.report.SectionHyperlink] = None)
      


case class KeyExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class ValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class LabelExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class OtherKeyExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class OtherLabelExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class SectionHyperlink(hyperlinkReferenceExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkReferenceExpression] = None,
  hyperlinkWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkWhenExpression] = None,
  hyperlinkAnchorExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkAnchorExpression] = None,
  hyperlinkPageExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkPageExpression] = None,
  hyperlinkTooltipExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkTooltipExpression] = None,
  hyperlinkParameter: Seq[com.iofficecorp.jasperserver.pumped.report.HyperlinkParameter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_hyperlinkType = attributes.get("@hyperlinkType") map { _.as[String] }
  lazy val attr_hyperlinkTarget = attributes.get("@hyperlinkTarget") map { _.as[String] }
}

      


case class OtherSectionHyperlink(hyperlinkReferenceExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkReferenceExpression] = None,
  hyperlinkWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkWhenExpression] = None,
  hyperlinkAnchorExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkAnchorExpression] = None,
  hyperlinkPageExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkPageExpression] = None,
  hyperlinkTooltipExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkTooltipExpression] = None,
  hyperlinkParameter: Seq[com.iofficecorp.jasperserver.pumped.report.HyperlinkParameter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_hyperlinkType = attributes.get("@hyperlinkType") map { _.as[String] }
  lazy val attr_hyperlinkTarget = attributes.get("@hyperlinkTarget") map { _.as[String] }
}

      

trait IsShowLabels

object IsShowLabels {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowLabels = value match {
    case "true" => TrueValue43
    case "false" => FalseValue43

  }
}

case object TrueValue43 extends IsShowLabels { override def toString = "true" }
case object FalseValue43 extends IsShowLabels { override def toString = "false" }

trait IsCircular

object IsCircular {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsCircular = value match {
    case "true" => TrueValue44
    case "false" => FalseValue44

  }
}

case object TrueValue44 extends IsCircular { override def toString = "true" }
case object FalseValue44 extends IsCircular { override def toString = "false" }


case class PiePlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  itemLabel: Option[com.iofficecorp.jasperserver.pumped.report.ItemLabel] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isShowLabels = attributes.get("@isShowLabels") map { _.as[IsShowLabels] }
  lazy val attr_isCircular = attributes.get("@isCircular") map { _.as[IsCircular] }
  lazy val attr_labelFormat = attributes.get("@labelFormat") map { _.as[String] }
  lazy val attr_legendLabelFormat = attributes.get("@legendLabelFormat") map { _.as[String] }
}

      

trait ResetTypeType

object ResetTypeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ResetTypeType = value match {
    case "None" => NoneTypeValue16
    case "Report" => ReportValue5
    case "Page" => PageValue5
    case "Column" => ColumnValue5
    case "Group" => GroupValue6

  }
}

case object NoneTypeValue16 extends ResetTypeType { override def toString = "None" }
case object ReportValue5 extends ResetTypeType { override def toString = "Report" }
case object PageValue5 extends ResetTypeType { override def toString = "Page" }
case object ColumnValue5 extends ResetTypeType { override def toString = "Column" }
case object GroupValue6 extends ResetTypeType { override def toString = "Group" }

trait IncrementTypeType

object IncrementTypeType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IncrementTypeType = value match {
    case "None" => NoneTypeValue17
    case "Report" => ReportValue6
    case "Page" => PageValue6
    case "Column" => ColumnValue6
    case "Group" => GroupValue7

  }
}

case object NoneTypeValue17 extends IncrementTypeType { override def toString = "None" }
case object ReportValue6 extends IncrementTypeType { override def toString = "Report" }
case object PageValue6 extends IncrementTypeType { override def toString = "Page" }
case object ColumnValue6 extends IncrementTypeType { override def toString = "Column" }
case object GroupValue7 extends IncrementTypeType { override def toString = "Group" }


case class Dataset(incrementWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.IncrementWhenExpression] = None,
  datasetRun: Option[com.iofficecorp.jasperserver.pumped.report.DatasetRun] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_resetType = attributes.get("@resetType") map { _.as[ResetTypeType] }
  lazy val attr_resetGroup = attributes.get("@resetGroup") map { _.as[String] }
  lazy val attr_incrementType = attributes("@incrementType").as[IncrementTypeType]
  lazy val attr_incrementGroup = attributes.get("@incrementGroup") map { _.as[String] }
}

      


case class IncrementWhenExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class DatasetRun(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  parametersMapExpression: Option[com.iofficecorp.jasperserver.pumped.report.ParametersMapExpression] = None,
  datasetParameter: Seq[com.iofficecorp.jasperserver.pumped.report.DatasetParameter] = Nil,
  datasetrunoption: Option[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.DatasetRunOption]] = None,
  returnValue: Seq[com.iofficecorp.jasperserver.pumped.report.DatasetReturnValue] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_subDataset = attributes("@subDataset").as[String]
  lazy val attr_uuid = attributes.get("@uuid") map { _.as[String] }
}

      

trait DatasetRunOption
trait CalculationType2

object CalculationType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): CalculationType2 = value match {
    case "Nothing" => NothingValue3
    case "Count" => CountValue3
    case "DistinctCount" => DistinctCountValue3
    case "Sum" => SumValue3
    case "Average" => AverageValue3
    case "Lowest" => LowestValue3
    case "Highest" => HighestValue3
    case "StandardDeviation" => StandardDeviationValue3
    case "Variance" => VarianceValue3
    case "First" => FirstValue3

  }
}

case object NothingValue3 extends CalculationType2 { override def toString = "Nothing" }
case object CountValue3 extends CalculationType2 { override def toString = "Count" }
case object DistinctCountValue3 extends CalculationType2 { override def toString = "DistinctCount" }
case object SumValue3 extends CalculationType2 { override def toString = "Sum" }
case object AverageValue3 extends CalculationType2 { override def toString = "Average" }
case object LowestValue3 extends CalculationType2 { override def toString = "Lowest" }
case object HighestValue3 extends CalculationType2 { override def toString = "Highest" }
case object StandardDeviationValue3 extends CalculationType2 { override def toString = "StandardDeviation" }
case object VarianceValue3 extends CalculationType2 { override def toString = "Variance" }
case object FirstValue3 extends CalculationType2 { override def toString = "First" }


case class DatasetReturnValue(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_fromVariable = attributes.get("@fromVariable") map { _.as[String] }
  lazy val attr_toVariable = attributes.get("@toVariable") map { _.as[String] }
  lazy val attr_calculation = attributes("@calculation").as[CalculationType2]
  lazy val attr_incrementerFactoryClass = attributes.get("@incrementerFactoryClass") map { _.as[String] }
}

      


case class DatasetParameter(datasetParameterExpression: Option[com.iofficecorp.jasperserver.pumped.report.DatasetParameterExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
}

      


case class DatasetParameterExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait OrientationType

object OrientationType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): OrientationType = value match {
    case "Horizontal" => HorizontalValue
    case "Vertical" => VerticalValue

  }
}

case object HorizontalValue extends OrientationType { override def toString = "Horizontal" }
case object VerticalValue extends OrientationType { override def toString = "Vertical" }


case class Plot(seriesColor: Seq[com.iofficecorp.jasperserver.pumped.report.SeriesColor] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_backcolor = attributes.get("@backcolor") map { _.as[String] }
  lazy val attr_orientation = attributes.get("@orientation") map { _.as[OrientationType] }
  lazy val attr_backgroundAlpha = attributes.get("@backgroundAlpha") map { _.as[String] }
  lazy val attr_foregroundAlpha = attributes.get("@foregroundAlpha") map { _.as[String] }
  lazy val attr_labelRotation = attributes.get("@labelRotation") map { _.as[String] }
}

      


case class SeriesColor(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_seriesOrder = attributes("@seriesOrder").as[String]
  lazy val attr_color = attributes("@color").as[String]
}

      


case class Pie3DChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  pieDataset: com.iofficecorp.jasperserver.pumped.report.PieDataset,
  pie3DPlot: com.iofficecorp.jasperserver.pumped.report.Pie3DPlot) extends BandOption with ElementGroupOption with FrameOption
      

trait IsShowLabelsType

object IsShowLabelsType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowLabelsType = value match {
    case "true" => TrueValue45
    case "false" => FalseValue45

  }
}

case object TrueValue45 extends IsShowLabelsType { override def toString = "true" }
case object FalseValue45 extends IsShowLabelsType { override def toString = "false" }

trait IsCircularType

object IsCircularType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsCircularType = value match {
    case "true" => TrueValue46
    case "false" => FalseValue46

  }
}

case object TrueValue46 extends IsCircularType { override def toString = "true" }
case object FalseValue46 extends IsCircularType { override def toString = "false" }


case class Pie3DPlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  itemLabel: Option[com.iofficecorp.jasperserver.pumped.report.ItemLabel] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isShowLabels = attributes.get("@isShowLabels") map { _.as[IsShowLabelsType] }
  lazy val attr_depthFactor = attributes.get("@depthFactor") map { _.as[String] }
  lazy val attr_isCircular = attributes.get("@isCircular") map { _.as[IsCircularType] }
  lazy val attr_labelFormat = attributes.get("@labelFormat") map { _.as[String] }
  lazy val attr_legendLabelFormat = attributes.get("@legendLabelFormat") map { _.as[String] }
}

      


case class BarChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  categoryDataset: com.iofficecorp.jasperserver.pumped.report.CategoryDataset,
  barPlot: com.iofficecorp.jasperserver.pumped.report.BarPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      


case class CategoryDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  categorySeries: Seq[com.iofficecorp.jasperserver.pumped.report.CategorySeries] = Nil)
      


case class CategorySeries(seriesExpression: Option[com.iofficecorp.jasperserver.pumped.report.SeriesExpression] = None,
  categoryExpression: Option[com.iofficecorp.jasperserver.pumped.report.CategoryExpression] = None,
  valueExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueExpression] = None,
  labelExpression: Option[com.iofficecorp.jasperserver.pumped.report.LabelExpression] = None,
  itemHyperlink: Option[com.iofficecorp.jasperserver.pumped.report.ItemHyperlink] = None)
      


case class SeriesExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class CategoryExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class ItemHyperlink(hyperlinkReferenceExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkReferenceExpression] = None,
  hyperlinkWhenExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkWhenExpression] = None,
  hyperlinkAnchorExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkAnchorExpression] = None,
  hyperlinkPageExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkPageExpression] = None,
  hyperlinkTooltipExpression: Option[com.iofficecorp.jasperserver.pumped.report.HyperlinkTooltipExpression] = None,
  hyperlinkParameter: Seq[com.iofficecorp.jasperserver.pumped.report.HyperlinkParameter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_hyperlinkType = attributes.get("@hyperlinkType") map { _.as[String] }
  lazy val attr_hyperlinkTarget = attributes.get("@hyperlinkTarget") map { _.as[String] }
}

      

trait IsShowLabelsType2

object IsShowLabelsType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowLabelsType2 = value match {
    case "true" => TrueValue47
    case "false" => FalseValue47

  }
}

case object TrueValue47 extends IsShowLabelsType2 { override def toString = "true" }
case object FalseValue47 extends IsShowLabelsType2 { override def toString = "false" }

trait IsShowTickMarks

object IsShowTickMarks {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowTickMarks = value match {
    case "true" => TrueValue48
    case "false" => FalseValue48

  }
}

case object TrueValue48 extends IsShowTickMarks { override def toString = "true" }
case object FalseValue48 extends IsShowTickMarks { override def toString = "false" }

trait IsShowTickLabels

object IsShowTickLabels {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowTickLabels = value match {
    case "true" => TrueValue49
    case "false" => FalseValue49

  }
}

case object TrueValue49 extends IsShowTickLabels { override def toString = "true" }
case object FalseValue49 extends IsShowTickLabels { override def toString = "false" }


case class BarPlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  itemLabel: Option[com.iofficecorp.jasperserver.pumped.report.ItemLabel] = None,
  categoryAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.CategoryAxisLabelExpression] = None,
  categoryAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.CategoryAxisFormat] = None,
  valueAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisLabelExpression] = None,
  valueAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisFormat] = None,
  domainAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMinValueExpression] = None,
  domainAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMaxValueExpression] = None,
  rangeAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMinValueExpression] = None,
  rangeAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMaxValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isShowLabels = attributes.get("@isShowLabels") map { _.as[IsShowLabelsType2] }
  lazy val attr_isShowTickMarks = attributes.get("@isShowTickMarks") map { _.as[IsShowTickMarks] }
  lazy val attr_isShowTickLabels = attributes.get("@isShowTickLabels") map { _.as[IsShowTickLabels] }
}

      


case class CategoryAxisLabelExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class ValueAxisLabelExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class DomainAxisMinValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class DomainAxisMaxValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class RangeAxisMinValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class RangeAxisMaxValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class CategoryAxisFormat(axisFormat: com.iofficecorp.jasperserver.pumped.report.AxisFormat,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_labelRotation = attributes.get("@labelRotation") map { _.as[String] }
}

      


case class ValueAxisFormat(axisFormat: com.iofficecorp.jasperserver.pumped.report.AxisFormat)
      


case class AxisFormat(labelFont: Option[com.iofficecorp.jasperserver.pumped.report.LabelFont] = None,
  tickLabelFont: Option[com.iofficecorp.jasperserver.pumped.report.TickLabelFont] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_labelColor = attributes.get("@labelColor") map { _.as[String] }
  lazy val attr_tickLabelColor = attributes.get("@tickLabelColor") map { _.as[String] }
  lazy val attr_tickLabelMask = attributes.get("@tickLabelMask") map { _.as[String] }
  lazy val attr_verticalTickLabels = attributes.get("@verticalTickLabels") map { _.as[Boolean] }
  lazy val attr_axisLineColor = attributes.get("@axisLineColor") map { _.as[String] }
}

      


case class LabelFont(font: Option[com.iofficecorp.jasperserver.pumped.report.Font] = None)
      


case class TickLabelFont(font: Option[com.iofficecorp.jasperserver.pumped.report.Font] = None)
      


case class Bar3DChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  categoryDataset: com.iofficecorp.jasperserver.pumped.report.CategoryDataset,
  bar3DPlot: com.iofficecorp.jasperserver.pumped.report.Bar3DPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      

trait IsShowLabelsType3

object IsShowLabelsType3 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowLabelsType3 = value match {
    case "true" => TrueValue50
    case "false" => FalseValue50

  }
}

case object TrueValue50 extends IsShowLabelsType3 { override def toString = "true" }
case object FalseValue50 extends IsShowLabelsType3 { override def toString = "false" }


case class Bar3DPlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  itemLabel: Option[com.iofficecorp.jasperserver.pumped.report.ItemLabel] = None,
  categoryAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.CategoryAxisLabelExpression] = None,
  categoryAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.CategoryAxisFormat] = None,
  valueAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisLabelExpression] = None,
  valueAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisFormat] = None,
  domainAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMinValueExpression] = None,
  domainAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMaxValueExpression] = None,
  rangeAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMinValueExpression] = None,
  rangeAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMaxValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isShowLabels = attributes.get("@isShowLabels") map { _.as[IsShowLabelsType3] }
  lazy val attr_xOffset = attributes.get("@xOffset") map { _.as[String] }
  lazy val attr_yOffset = attributes.get("@yOffset") map { _.as[String] }
}

      


case class XyBarChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  xybarchartoption: scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.XyBarChartOption],
  barPlot: com.iofficecorp.jasperserver.pumped.report.BarPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      

trait XyBarChartOption

case class TimePeriodDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  timePeriodSeries: Seq[com.iofficecorp.jasperserver.pumped.report.TimePeriodSeries] = Nil) extends XyBarChartOption
      


case class TimePeriodSeries(seriesExpression: Option[com.iofficecorp.jasperserver.pumped.report.SeriesExpression] = None,
  startDateExpression: Option[com.iofficecorp.jasperserver.pumped.report.StartDateExpression] = None,
  endDateExpression: Option[com.iofficecorp.jasperserver.pumped.report.EndDateExpression] = None,
  valueExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueExpression] = None,
  labelExpression: Option[com.iofficecorp.jasperserver.pumped.report.LabelExpression] = None,
  itemHyperlink: Option[com.iofficecorp.jasperserver.pumped.report.ItemHyperlink] = None)
      


case class StartDateExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class EndDateExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class StackedBarChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  categoryDataset: com.iofficecorp.jasperserver.pumped.report.CategoryDataset,
  barPlot: com.iofficecorp.jasperserver.pumped.report.BarPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      


case class StackedAreaChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  categoryDataset: com.iofficecorp.jasperserver.pumped.report.CategoryDataset,
  areaPlot: com.iofficecorp.jasperserver.pumped.report.AreaPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      


case class StackedBar3DChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  categoryDataset: com.iofficecorp.jasperserver.pumped.report.CategoryDataset,
  bar3DPlot: com.iofficecorp.jasperserver.pumped.report.Bar3DPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      


case class LineChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  categoryDataset: com.iofficecorp.jasperserver.pumped.report.CategoryDataset,
  linePlot: com.iofficecorp.jasperserver.pumped.report.LinePlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      

trait IsShowLines

object IsShowLines {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowLines = value match {
    case "true" => TrueValue51
    case "false" => FalseValue51

  }
}

case object TrueValue51 extends IsShowLines { override def toString = "true" }
case object FalseValue51 extends IsShowLines { override def toString = "false" }

trait IsShowShapes

object IsShowShapes {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowShapes = value match {
    case "true" => TrueValue52
    case "false" => FalseValue52

  }
}

case object TrueValue52 extends IsShowShapes { override def toString = "true" }
case object FalseValue52 extends IsShowShapes { override def toString = "false" }


case class LinePlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  categoryAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.CategoryAxisLabelExpression] = None,
  categoryAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.CategoryAxisFormat] = None,
  valueAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisLabelExpression] = None,
  valueAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisFormat] = None,
  domainAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMinValueExpression] = None,
  domainAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMaxValueExpression] = None,
  rangeAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMinValueExpression] = None,
  rangeAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMaxValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isShowLines = attributes.get("@isShowLines") map { _.as[IsShowLines] }
  lazy val attr_isShowShapes = attributes.get("@isShowShapes") map { _.as[IsShowShapes] }
}

      


case class XyLineChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  xyDataset: com.iofficecorp.jasperserver.pumped.report.XyDataset,
  linePlot: com.iofficecorp.jasperserver.pumped.report.LinePlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      


case class XyDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  xySeries: Seq[com.iofficecorp.jasperserver.pumped.report.XySeries] = Nil) extends XyBarChartOption
      

trait AutoSort

object AutoSort {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): AutoSort = value match {
    case "true" => TrueValue53
    case "false" => FalseValue53

  }
}

case object TrueValue53 extends AutoSort { override def toString = "true" }
case object FalseValue53 extends AutoSort { override def toString = "false" }


case class XySeries(seriesExpression: Option[com.iofficecorp.jasperserver.pumped.report.SeriesExpression] = None,
  xValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.XValueExpression] = None,
  yValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.YValueExpression] = None,
  labelExpression: Option[com.iofficecorp.jasperserver.pumped.report.LabelExpression] = None,
  itemHyperlink: Option[com.iofficecorp.jasperserver.pumped.report.ItemHyperlink] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_autoSort = attributes.get("@autoSort") map { _.as[AutoSort] }
}

      


case class XValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class YValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class AreaChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  categoryDataset: com.iofficecorp.jasperserver.pumped.report.CategoryDataset,
  areaPlot: com.iofficecorp.jasperserver.pumped.report.AreaPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      


case class AreaPlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  categoryAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.CategoryAxisLabelExpression] = None,
  categoryAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.CategoryAxisFormat] = None,
  valueAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisLabelExpression] = None,
  valueAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisFormat] = None,
  domainAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMinValueExpression] = None,
  domainAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMaxValueExpression] = None,
  rangeAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMinValueExpression] = None,
  rangeAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMaxValueExpression] = None)
      


case class XyAreaChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  xyDataset: com.iofficecorp.jasperserver.pumped.report.XyDataset,
  areaPlot: com.iofficecorp.jasperserver.pumped.report.AreaPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      


case class ScatterChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  xyDataset: com.iofficecorp.jasperserver.pumped.report.XyDataset,
  scatterPlot: com.iofficecorp.jasperserver.pumped.report.ScatterPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      

trait IsShowLinesType

object IsShowLinesType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowLinesType = value match {
    case "true" => TrueValue54
    case "false" => FalseValue54

  }
}

case object TrueValue54 extends IsShowLinesType { override def toString = "true" }
case object FalseValue54 extends IsShowLinesType { override def toString = "false" }

trait IsShowShapesType

object IsShowShapesType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowShapesType = value match {
    case "true" => TrueValue55
    case "false" => FalseValue55

  }
}

case object TrueValue55 extends IsShowShapesType { override def toString = "true" }
case object FalseValue55 extends IsShowShapesType { override def toString = "false" }


case class ScatterPlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  xAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.XAxisLabelExpression] = None,
  xAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.XAxisFormat] = None,
  yAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.YAxisLabelExpression] = None,
  yAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.YAxisFormat] = None,
  domainAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMinValueExpression] = None,
  domainAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMaxValueExpression] = None,
  rangeAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMinValueExpression] = None,
  rangeAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMaxValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isShowLines = attributes.get("@isShowLines") map { _.as[IsShowLinesType] }
  lazy val attr_isShowShapes = attributes.get("@isShowShapes") map { _.as[IsShowShapesType] }
}

      


case class XAxisLabelExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class YAxisLabelExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class XAxisFormat(axisFormat: com.iofficecorp.jasperserver.pumped.report.AxisFormat)
      


case class YAxisFormat(axisFormat: com.iofficecorp.jasperserver.pumped.report.AxisFormat)
      


case class BubbleChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  xyzDataset: com.iofficecorp.jasperserver.pumped.report.XyzDataset,
  bubblePlot: com.iofficecorp.jasperserver.pumped.report.BubblePlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      


case class XyzDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  xyzSeries: Seq[com.iofficecorp.jasperserver.pumped.report.XyzSeries] = Nil)
      


case class XyzSeries(seriesExpression: Option[com.iofficecorp.jasperserver.pumped.report.SeriesExpression] = None,
  xValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.XValueExpression] = None,
  yValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.YValueExpression] = None,
  zValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.ZValueExpression] = None,
  itemHyperlink: Option[com.iofficecorp.jasperserver.pumped.report.ItemHyperlink] = None)
      

trait ScaleType

object ScaleType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ScaleType = value match {
    case "BothAxes" => BothAxes
    case "DomainAxis" => DomainAxis
    case "RangeAxis" => RangeAxis

  }
}

case object BothAxes extends ScaleType { override def toString = "BothAxes" }
case object DomainAxis extends ScaleType { override def toString = "DomainAxis" }
case object RangeAxis extends ScaleType { override def toString = "RangeAxis" }


case class BubblePlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  xAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.XAxisLabelExpression] = None,
  xAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.XAxisFormat] = None,
  yAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.YAxisLabelExpression] = None,
  yAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.YAxisFormat] = None,
  domainAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMinValueExpression] = None,
  domainAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMaxValueExpression] = None,
  rangeAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMinValueExpression] = None,
  rangeAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMaxValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_scaleType = attributes.get("@scaleType") map { _.as[ScaleType] }
}

      


case class ZValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait TimePeriod

object TimePeriod {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TimePeriod = value match {
    case "Year" => Year
    case "Quarter" => Quarter
    case "Month" => Month
    case "Week" => Week
    case "Day" => Day
    case "Hour" => Hour
    case "Minute" => Minute
    case "Second" => Second
    case "Milisecond" => Milisecond

  }
}

case object Year extends TimePeriod { override def toString = "Year" }
case object Quarter extends TimePeriod { override def toString = "Quarter" }
case object Month extends TimePeriod { override def toString = "Month" }
case object Week extends TimePeriod { override def toString = "Week" }
case object Day extends TimePeriod { override def toString = "Day" }
case object Hour extends TimePeriod { override def toString = "Hour" }
case object Minute extends TimePeriod { override def toString = "Minute" }
case object Second extends TimePeriod { override def toString = "Second" }
case object Milisecond extends TimePeriod { override def toString = "Milisecond" }


case class TimeSeriesDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  timeSeries: Seq[com.iofficecorp.jasperserver.pumped.report.TimeSeries] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends XyBarChartOption {
  lazy val attr_timePeriod = attributes("@timePeriod").as[TimePeriod]
}

      


case class TimeSeries(seriesExpression: Option[com.iofficecorp.jasperserver.pumped.report.SeriesExpression] = None,
  timePeriodExpression: Option[com.iofficecorp.jasperserver.pumped.report.TimePeriodExpression] = None,
  valueExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueExpression] = None,
  labelExpression: Option[com.iofficecorp.jasperserver.pumped.report.LabelExpression] = None,
  itemHyperlink: Option[com.iofficecorp.jasperserver.pumped.report.ItemHyperlink] = None)
      


case class TimePeriodExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class TimeSeriesChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  timeSeriesDataset: com.iofficecorp.jasperserver.pumped.report.TimeSeriesDataset,
  timeSeriesPlot: com.iofficecorp.jasperserver.pumped.report.TimeSeriesPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      

trait IsShowLinesType2

object IsShowLinesType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowLinesType2 = value match {
    case "true" => TrueValue56
    case "false" => FalseValue56

  }
}

case object TrueValue56 extends IsShowLinesType2 { override def toString = "true" }
case object FalseValue56 extends IsShowLinesType2 { override def toString = "false" }

trait IsShowShapesType2

object IsShowShapesType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowShapesType2 = value match {
    case "true" => TrueValue57
    case "false" => FalseValue57

  }
}

case object TrueValue57 extends IsShowShapesType2 { override def toString = "true" }
case object FalseValue57 extends IsShowShapesType2 { override def toString = "false" }


case class TimeSeriesPlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  timeAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.TimeAxisLabelExpression] = None,
  timeAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.TimeAxisFormat] = None,
  valueAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisLabelExpression] = None,
  valueAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisFormat] = None,
  domainAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMinValueExpression] = None,
  domainAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMaxValueExpression] = None,
  rangeAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMinValueExpression] = None,
  rangeAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMaxValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isShowLines = attributes.get("@isShowLines") map { _.as[IsShowLinesType2] }
  lazy val attr_isShowShapes = attributes.get("@isShowShapes") map { _.as[IsShowShapesType2] }
}

      


case class TimeAxisLabelExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class TimeAxisFormat(axisFormat: com.iofficecorp.jasperserver.pumped.report.AxisFormat)
      


case class HighLowChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  highLowDataset: com.iofficecorp.jasperserver.pumped.report.HighLowDataset,
  highLowPlot: com.iofficecorp.jasperserver.pumped.report.HighLowPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      


case class HighLowDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  seriesExpression: Option[com.iofficecorp.jasperserver.pumped.report.SeriesExpression] = None,
  dateExpression: Option[com.iofficecorp.jasperserver.pumped.report.DateExpression] = None,
  highExpression: Option[com.iofficecorp.jasperserver.pumped.report.HighExpression] = None,
  lowExpression: Option[com.iofficecorp.jasperserver.pumped.report.LowExpression] = None,
  openExpression: Option[com.iofficecorp.jasperserver.pumped.report.OpenExpression] = None,
  closeExpression: Option[com.iofficecorp.jasperserver.pumped.report.CloseExpression] = None,
  volumeExpression: Option[com.iofficecorp.jasperserver.pumped.report.VolumeExpression] = None,
  itemHyperlink: Option[com.iofficecorp.jasperserver.pumped.report.ItemHyperlink] = None)
      

trait IsShowCloseTicks

object IsShowCloseTicks {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowCloseTicks = value match {
    case "true" => TrueValue58
    case "false" => FalseValue58

  }
}

case object TrueValue58 extends IsShowCloseTicks { override def toString = "true" }
case object FalseValue58 extends IsShowCloseTicks { override def toString = "false" }

trait IsShowOpenTicks

object IsShowOpenTicks {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowOpenTicks = value match {
    case "true" => TrueValue59
    case "false" => FalseValue59

  }
}

case object TrueValue59 extends IsShowOpenTicks { override def toString = "true" }
case object FalseValue59 extends IsShowOpenTicks { override def toString = "false" }


case class HighLowPlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  timeAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.TimeAxisLabelExpression] = None,
  timeAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.TimeAxisFormat] = None,
  valueAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisLabelExpression] = None,
  valueAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisFormat] = None,
  domainAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMinValueExpression] = None,
  domainAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMaxValueExpression] = None,
  rangeAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMinValueExpression] = None,
  rangeAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMaxValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isShowCloseTicks = attributes.get("@isShowCloseTicks") map { _.as[IsShowCloseTicks] }
  lazy val attr_isShowOpenTicks = attributes.get("@isShowOpenTicks") map { _.as[IsShowOpenTicks] }
}

      


case class DateExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class HighExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class LowExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class OpenExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class CloseExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class VolumeExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class CandlestickChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  highLowDataset: com.iofficecorp.jasperserver.pumped.report.HighLowDataset,
  candlestickPlot: com.iofficecorp.jasperserver.pumped.report.CandlestickPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      

trait IsShowVolume

object IsShowVolume {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowVolume = value match {
    case "true" => TrueValue60
    case "false" => FalseValue60

  }
}

case object TrueValue60 extends IsShowVolume { override def toString = "true" }
case object FalseValue60 extends IsShowVolume { override def toString = "false" }


case class CandlestickPlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  timeAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.TimeAxisLabelExpression] = None,
  timeAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.TimeAxisFormat] = None,
  valueAxisLabelExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisLabelExpression] = None,
  valueAxisFormat: Option[com.iofficecorp.jasperserver.pumped.report.ValueAxisFormat] = None,
  domainAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMinValueExpression] = None,
  domainAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.DomainAxisMaxValueExpression] = None,
  rangeAxisMinValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMinValueExpression] = None,
  rangeAxisMaxValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.RangeAxisMaxValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isShowVolume = attributes.get("@isShowVolume") map { _.as[IsShowVolume] }
}

      


case class MeterChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  valueDataset: com.iofficecorp.jasperserver.pumped.report.ValueDataset,
  meterPlot: com.iofficecorp.jasperserver.pumped.report.MeterPlot) extends BandOption with ElementGroupOption with FrameOption
      


case class ValueDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  valueExpression: com.iofficecorp.jasperserver.pumped.report.ValueExpression)
      

trait Shape

object Shape {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): Shape = value match {
    case "chord" => Chord
    case "circle" => Circle
    case "pie" => Pie
    case "dial" => Dial

  }
}

case object Chord extends Shape { override def toString = "chord" }
case object Circle extends Shape { override def toString = "circle" }
case object Pie extends Shape { override def toString = "pie" }
case object Dial extends Shape { override def toString = "dial" }


case class MeterPlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  tickLabelFont: Option[com.iofficecorp.jasperserver.pumped.report.TickLabelFont] = None,
  valueDisplay: Option[com.iofficecorp.jasperserver.pumped.report.ValueDisplay] = None,
  dataRange: com.iofficecorp.jasperserver.pumped.report.DataRange,
  meterInterval: Seq[com.iofficecorp.jasperserver.pumped.report.MeterInterval] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_shape = attributes.get("@shape") map { _.as[Shape] }
  lazy val attr_angle = attributes.get("@angle") map { _.as[String] }
  lazy val attr_units = attributes.get("@units") map { _.as[String] }
  lazy val attr_tickInterval = attributes.get("@tickInterval") map { _.as[String] }
  lazy val attr_meterColor = attributes.get("@meterColor") map { _.as[String] }
  lazy val attr_needleColor = attributes.get("@needleColor") map { _.as[String] }
  lazy val attr_tickColor = attributes.get("@tickColor") map { _.as[String] }
  lazy val attr_tickCount = attributes.get("@tickCount") map { _.as[String] }
}

      


case class ValueDisplay(font: Option[com.iofficecorp.jasperserver.pumped.report.Font] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_color = attributes.get("@color") map { _.as[String] }
  lazy val attr_mask = attributes.get("@mask") map { _.as[String] }
}

      


case class DataRange(lowExpression: com.iofficecorp.jasperserver.pumped.report.LowExpression,
  highExpression: com.iofficecorp.jasperserver.pumped.report.HighExpression)
      


case class MeterInterval(dataRange: com.iofficecorp.jasperserver.pumped.report.DataRange,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_label = attributes.get("@label") map { _.as[String] }
  lazy val attr_color = attributes.get("@color") map { _.as[String] }
  lazy val attr_alpha = attributes.get("@alpha") map { _.as[String] }
}

      


case class ThermometerChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  valueDataset: com.iofficecorp.jasperserver.pumped.report.ValueDataset,
  thermometerPlot: com.iofficecorp.jasperserver.pumped.report.ThermometerPlot) extends BandOption with ElementGroupOption with FrameOption
      

trait ValueLocation

object ValueLocation {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ValueLocation = value match {
    case "none" => NoneTypeValue18
    case "left" => LeftTypeValue10
    case "right" => RightTypeValue10
    case "bulb" => Bulb

  }
}

case object NoneTypeValue18 extends ValueLocation { override def toString = "none" }
case object LeftTypeValue10 extends ValueLocation { override def toString = "left" }
case object RightTypeValue10 extends ValueLocation { override def toString = "right" }
case object Bulb extends ValueLocation { override def toString = "bulb" }

trait IsShowValueLines

object IsShowValueLines {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsShowValueLines = value match {
    case "true" => TrueValue61
    case "false" => FalseValue61

  }
}

case object TrueValue61 extends IsShowValueLines { override def toString = "true" }
case object FalseValue61 extends IsShowValueLines { override def toString = "false" }


case class ThermometerPlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  valueDisplay: Option[com.iofficecorp.jasperserver.pumped.report.ValueDisplay] = None,
  dataRange: com.iofficecorp.jasperserver.pumped.report.DataRange,
  lowRange: Option[com.iofficecorp.jasperserver.pumped.report.LowRange] = None,
  mediumRange: Option[com.iofficecorp.jasperserver.pumped.report.MediumRange] = None,
  highRange: Option[com.iofficecorp.jasperserver.pumped.report.HighRange] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_valueLocation = attributes("@valueLocation").as[ValueLocation]
  lazy val attr_isShowValueLines = attributes("@isShowValueLines").as[IsShowValueLines]
  lazy val attr_mercuryColor = attributes.get("@mercuryColor") map { _.as[String] }
}

      


case class LowRange(dataRange: com.iofficecorp.jasperserver.pumped.report.DataRange)
      


case class MediumRange(dataRange: com.iofficecorp.jasperserver.pumped.report.DataRange)
      


case class HighRange(dataRange: com.iofficecorp.jasperserver.pumped.report.DataRange)
      


case class MultiAxisChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  multiAxisPlot: com.iofficecorp.jasperserver.pumped.report.MultiAxisPlot) extends BandOption with ElementGroupOption with FrameOption
      


case class MultiAxisPlot(plot: com.iofficecorp.jasperserver.pumped.report.Plot,
  axis: Seq[com.iofficecorp.jasperserver.pumped.report.Axis] = Nil)
      

trait PositionType3

object PositionType3 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): PositionType3 = value match {
    case "leftOrTop" => LeftOrTop
    case "rightOrBottom" => RightOrBottom

  }
}

case object LeftOrTop extends PositionType3 { override def toString = "leftOrTop" }
case object RightOrBottom extends PositionType3 { override def toString = "rightOrBottom" }


case class Axis(axisoption: scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.AxisOption],
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_position = attributes.get("@position") map { _.as[PositionType3] }
}

      

trait AxisOption
trait IsRepeatColumnHeaders

object IsRepeatColumnHeaders {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsRepeatColumnHeaders = value match {
    case "true" => TrueValue62
    case "false" => FalseValue62

  }
}

case object TrueValue62 extends IsRepeatColumnHeaders { override def toString = "true" }
case object FalseValue62 extends IsRepeatColumnHeaders { override def toString = "false" }

trait IsRepeatRowHeaders

object IsRepeatRowHeaders {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsRepeatRowHeaders = value match {
    case "true" => TrueValue63
    case "false" => FalseValue63

  }
}

case object TrueValue63 extends IsRepeatRowHeaders { override def toString = "true" }
case object FalseValue63 extends IsRepeatRowHeaders { override def toString = "false" }

trait RunDirection

object RunDirection {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): RunDirection = value match {
    case "LTR" => LTRValue
    case "RTL" => RTLValue

  }
}

case object LTRValue extends RunDirection { override def toString = "LTR" }
case object RTLValue extends RunDirection { override def toString = "RTL" }

trait HorizontalPosition

object HorizontalPosition {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): HorizontalPosition = value match {
    case "Left" => LeftTypeValue11
    case "Right" => RightTypeValue11
    case "Center" => CenterValue6

  }
}

case object LeftTypeValue11 extends HorizontalPosition { override def toString = "Left" }
case object RightTypeValue11 extends HorizontalPosition { override def toString = "Right" }
case object CenterValue6 extends HorizontalPosition { override def toString = "Center" }


case class Crosstab(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  box: Option[com.iofficecorp.jasperserver.pumped.report.Box] = None,
  crosstabParameter: Seq[com.iofficecorp.jasperserver.pumped.report.CrosstabParameter] = Nil,
  parametersMapExpression: Option[com.iofficecorp.jasperserver.pumped.report.ParametersMapExpression] = None,
  crosstabDataset: Option[com.iofficecorp.jasperserver.pumped.report.CrosstabDataset] = None,
  titleCell: Option[com.iofficecorp.jasperserver.pumped.report.CrosstabColumnCell] = None,
  crosstabHeaderCell: Option[com.iofficecorp.jasperserver.pumped.report.CrosstabHeaderCell] = None,
  rowGroup: Seq[com.iofficecorp.jasperserver.pumped.report.RowGroup] = Nil,
  columnGroup: Seq[com.iofficecorp.jasperserver.pumped.report.ColumnGroup] = Nil,
  measure: Seq[com.iofficecorp.jasperserver.pumped.report.Measure] = Nil,
  crosstabCell: Seq[com.iofficecorp.jasperserver.pumped.report.CrosstabCell] = Nil,
  whenNoDataCell: Option[com.iofficecorp.jasperserver.pumped.report.WhenNoDataCell] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BandOption with ElementGroupOption with FrameOption {
  lazy val attr_isRepeatColumnHeaders = attributes("@isRepeatColumnHeaders").as[IsRepeatColumnHeaders]
  lazy val attr_isRepeatRowHeaders = attributes("@isRepeatRowHeaders").as[IsRepeatRowHeaders]
  lazy val attr_columnBreakOffset = attributes("@columnBreakOffset").as[String]
  lazy val attr_runDirection = attributes("@runDirection").as[RunDirection]
  lazy val attr_ignoreWidth = attributes.get("@ignoreWidth") map { _.as[Boolean] }
  lazy val attr_horizontalPosition = attributes.get("@horizontalPosition") map { _.as[HorizontalPosition] }
}

      


case class CrosstabParameter(parameterValueExpression: Option[com.iofficecorp.jasperserver.pumped.report.ParameterValueExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_class = attributes("@class").as[String]
}

      


case class ParameterValueExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait IsDataPreSorted

object IsDataPreSorted {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): IsDataPreSorted = value match {
    case "true" => TrueValue64
    case "false" => FalseValue64

  }
}

case object TrueValue64 extends IsDataPreSorted { override def toString = "true" }
case object FalseValue64 extends IsDataPreSorted { override def toString = "false" }


case class CrosstabDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_isDataPreSorted = attributes("@isDataPreSorted").as[IsDataPreSorted]
}

      


case class CrosstabHeaderCell(cellContents: com.iofficecorp.jasperserver.pumped.report.CellContents)
      

trait TotalPosition

object TotalPosition {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TotalPosition = value match {
    case "Start" => Start
    case "End" => End
    case "None" => NoneTypeValue19

  }
}

case object Start extends TotalPosition { override def toString = "Start" }
case object End extends TotalPosition { override def toString = "End" }
case object NoneTypeValue19 extends TotalPosition { override def toString = "None" }

trait HeaderPosition

object HeaderPosition {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): HeaderPosition = value match {
    case "Top" => TopValue7
    case "Middle" => MiddleValue5
    case "Bottom" => BottomValue7
    case "Stretch" => StretchValue2

  }
}

case object TopValue7 extends HeaderPosition { override def toString = "Top" }
case object MiddleValue5 extends HeaderPosition { override def toString = "Middle" }
case object BottomValue7 extends HeaderPosition { override def toString = "Bottom" }
case object StretchValue2 extends HeaderPosition { override def toString = "Stretch" }


case class RowGroup(bucket: com.iofficecorp.jasperserver.pumped.report.Bucket,
  crosstabRowHeader: Option[com.iofficecorp.jasperserver.pumped.report.CrosstabRowHeader] = None,
  crosstabTotalRowHeader: Option[com.iofficecorp.jasperserver.pumped.report.CrosstabTotalRowHeader] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_width = attributes("@width").as[String]
  lazy val attr_totalPosition = attributes("@totalPosition").as[TotalPosition]
  lazy val attr_headerPosition = attributes("@headerPosition").as[HeaderPosition]
}

      


case class CrosstabRowHeader(cellContents: Option[com.iofficecorp.jasperserver.pumped.report.CellContents] = None)
      


case class CrosstabTotalRowHeader(cellContents: Option[com.iofficecorp.jasperserver.pumped.report.CellContents] = None)
      

trait TotalPositionType

object TotalPositionType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): TotalPositionType = value match {
    case "Start" => StartValue
    case "End" => EndValue
    case "None" => NoneTypeValue20

  }
}

case object StartValue extends TotalPositionType { override def toString = "Start" }
case object EndValue extends TotalPositionType { override def toString = "End" }
case object NoneTypeValue20 extends TotalPositionType { override def toString = "None" }

trait HeaderPositionType

object HeaderPositionType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): HeaderPositionType = value match {
    case "Left" => LeftTypeValue12
    case "Center" => CenterValue7
    case "Right" => RightTypeValue12
    case "Stretch" => StretchValue3

  }
}

case object LeftTypeValue12 extends HeaderPositionType { override def toString = "Left" }
case object CenterValue7 extends HeaderPositionType { override def toString = "Center" }
case object RightTypeValue12 extends HeaderPositionType { override def toString = "Right" }
case object StretchValue3 extends HeaderPositionType { override def toString = "Stretch" }


case class ColumnGroup(bucket: com.iofficecorp.jasperserver.pumped.report.Bucket,
  crosstabHeader: Option[com.iofficecorp.jasperserver.pumped.report.CrosstabHeader] = None,
  crosstabColumnHeader: Option[com.iofficecorp.jasperserver.pumped.report.CrosstabColumnHeader] = None,
  crosstabTotalColumnHeader: Option[com.iofficecorp.jasperserver.pumped.report.CrosstabTotalColumnHeader] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_height = attributes("@height").as[String]
  lazy val attr_totalPosition = attributes("@totalPosition").as[TotalPositionType]
  lazy val attr_headerPosition = attributes("@headerPosition").as[HeaderPositionType]
}

      


case class CrosstabColumnHeader(cellContents: Option[com.iofficecorp.jasperserver.pumped.report.CellContents] = None)
      


case class CrosstabTotalColumnHeader(cellContents: Option[com.iofficecorp.jasperserver.pumped.report.CellContents] = None)
      


case class CrosstabHeader(cellContents: com.iofficecorp.jasperserver.pumped.report.CellContents)
      

trait OrderType

object OrderType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): OrderType = value match {
    case "Ascending" => AscendingValue
    case "Descending" => DescendingValue
    case "None" => NoneTypeValue21

  }
}

case object AscendingValue extends OrderType { override def toString = "Ascending" }
case object DescendingValue extends OrderType { override def toString = "Descending" }
case object NoneTypeValue21 extends OrderType { override def toString = "None" }


case class Bucket(bucketExpression: Option[com.iofficecorp.jasperserver.pumped.report.BucketExpression] = None,
  orderByExpression: Option[com.iofficecorp.jasperserver.pumped.report.OrderByExpression] = None,
  comparatorExpression: Option[com.iofficecorp.jasperserver.pumped.report.ComparatorExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_class = attributes("@class").as[String]
  lazy val attr_order = attributes("@order").as[OrderType]
}

      


case class BucketExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_class = attributes.get("@class") map { _.as[String] }
}

      


case class OrderByExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_class = attributes.get("@class") map { _.as[String] }
}

      


case class ComparatorExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      

trait PercentageOf

object PercentageOf {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): PercentageOf = value match {
    case "None" => NoneTypeValue22
    case "GrandTotal" => GrandTotal

  }
}

case object NoneTypeValue22 extends PercentageOf { override def toString = "None" }
case object GrandTotal extends PercentageOf { override def toString = "GrandTotal" }


case class Measure(measureExpression: Option[com.iofficecorp.jasperserver.pumped.report.MeasureExpression] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_class = attributes.get("@class") map { _.as[String] }
  lazy val attr_calculation = attributes("@calculation").as[AggregationCalculationType]
  lazy val attr_incrementerFactoryClass = attributes.get("@incrementerFactoryClass") map { _.as[String] }
  lazy val attr_percentageOf = attributes("@percentageOf").as[PercentageOf]
  lazy val attr_percentageCalculatorClass = attributes.get("@percentageCalculatorClass") map { _.as[String] }
}

      

trait AggregationCalculationType

object AggregationCalculationType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): AggregationCalculationType = value match {
    case "Nothing" => Nothing
    case "Count" => Count
    case "DistinctCount" => DistinctCount
    case "Sum" => Sum
    case "Average" => Average
    case "Lowest" => Lowest
    case "Highest" => Highest
    case "StandardDeviation" => StandardDeviation
    case "Variance" => Variance
    case "First" => First

  }
}

case object Nothing extends AggregationCalculationType { override def toString = "Nothing" }
case object Count extends AggregationCalculationType { override def toString = "Count" }
case object DistinctCount extends AggregationCalculationType { override def toString = "DistinctCount" }
case object Sum extends AggregationCalculationType { override def toString = "Sum" }
case object Average extends AggregationCalculationType { override def toString = "Average" }
case object Lowest extends AggregationCalculationType { override def toString = "Lowest" }
case object Highest extends AggregationCalculationType { override def toString = "Highest" }
case object StandardDeviation extends AggregationCalculationType { override def toString = "StandardDeviation" }
case object Variance extends AggregationCalculationType { override def toString = "Variance" }
case object First extends AggregationCalculationType { override def toString = "First" }


case class MeasureExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class CrosstabCell(cellContents: Option[com.iofficecorp.jasperserver.pumped.report.CellContents] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_width = attributes.get("@width") map { _.as[String] }
  lazy val attr_height = attributes.get("@height") map { _.as[String] }
  lazy val attr_rowTotalGroup = attributes.get("@rowTotalGroup") map { _.as[String] }
  lazy val attr_columnTotalGroup = attributes.get("@columnTotalGroup") map { _.as[String] }
}

      

trait ModeType2

object ModeType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ModeType2 = value match {
    case "Opaque" => OpaqueValue2
    case "Transparent" => TransparentValue2

  }
}

case object OpaqueValue2 extends ModeType2 { override def toString = "Opaque" }
case object TransparentValue2 extends ModeType2 { override def toString = "Transparent" }


case class CellContents(property: Seq[com.iofficecorp.jasperserver.pumped.report.Property] = Nil,
  box: Option[com.iofficecorp.jasperserver.pumped.report.Box] = None,
  cellcontentsoption: Seq[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.CellContentsOption]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_backcolor = attributes.get("@backcolor") map { _.as[String] }
  lazy val attr_mode = attributes.get("@mode") map { _.as[ModeType2] }
  lazy val attr_style = attributes.get("@style") map { _.as[String] }
}

      

trait CellContentsOption

case class WhenNoDataCell(cellContents: com.iofficecorp.jasperserver.pumped.report.CellContents)
      

trait BorderSplitType

object BorderSplitType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): BorderSplitType = value match {
    case "NoBorders" => NoBorders
    case "DrawBorders" => DrawBorders

  }
}

case object NoBorders extends BorderSplitType { override def toString = "NoBorders" }
case object DrawBorders extends BorderSplitType { override def toString = "DrawBorders" }


case class Frame(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  box: Option[com.iofficecorp.jasperserver.pumped.report.Box] = None,
  frameoption: Seq[scalaxb.DataRecord[com.iofficecorp.jasperserver.pumped.report.FrameOption]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BandOption with ElementGroupOption with CellContentsOption with FrameOption {
  lazy val attr_borderSplitType = attributes.get("@borderSplitType") map { _.as[BorderSplitType] }
}

      

trait FrameOption

case class GanttChart(chart: com.iofficecorp.jasperserver.pumped.report.Chart,
  ganttDataset: com.iofficecorp.jasperserver.pumped.report.GanttDataset,
  barPlot: com.iofficecorp.jasperserver.pumped.report.BarPlot) extends BandOption with ElementGroupOption with AxisOption with FrameOption
      


case class GanttDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None,
  ganttSeries: Seq[com.iofficecorp.jasperserver.pumped.report.GanttSeries] = Nil)
      


case class GanttSeries(seriesExpression: Option[com.iofficecorp.jasperserver.pumped.report.SeriesExpression] = None,
  taskExpression: com.iofficecorp.jasperserver.pumped.report.TaskExpression,
  subtaskExpression: com.iofficecorp.jasperserver.pumped.report.SubtaskExpression,
  startDateExpression: Option[com.iofficecorp.jasperserver.pumped.report.StartDateExpression] = None,
  endDateExpression: Option[com.iofficecorp.jasperserver.pumped.report.EndDateExpression] = None,
  percentExpression: Option[com.iofficecorp.jasperserver.pumped.report.PercentExpression] = None)
      


case class TaskExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class SubtaskExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class PercentExpression(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class ComponentElement(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  component: scalaxb.DataRecord[Any]) extends BandOption with ElementGroupOption with CellContentsOption with FrameOption
      


/** 
*/
trait ComponentType {
  
}

trait BasicEvaluationTime

object BasicEvaluationTime {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): BasicEvaluationTime = value match {
    case "Now" => Now
    case "Report" => Report
    case "Page" => Page
    case "Column" => Column
    case "Group" => GroupValue
    case "Band" => BandValue
    case "Master" => Master

  }
}

case object Now extends BasicEvaluationTime { override def toString = "Now" }
case object Report extends BasicEvaluationTime { override def toString = "Report" }
case object Page extends BasicEvaluationTime { override def toString = "Page" }
case object Column extends BasicEvaluationTime { override def toString = "Column" }
case object GroupValue extends BasicEvaluationTime { override def toString = "Group" }
case object BandValue extends BasicEvaluationTime { override def toString = "Band" }
case object Master extends BasicEvaluationTime { override def toString = "Master" }

trait ComplexEvaluationTime

object ComplexEvaluationTime {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ComplexEvaluationTime = value match {
    case "Now" => NowValue
    case "Report" => ReportValue
    case "Page" => PageValue
    case "Column" => ColumnValue
    case "Group" => GroupValue2
    case "Band" => BandValue2
    case "Auto" => Auto
    case "Master" => MasterValue

  }
}

case object NowValue extends ComplexEvaluationTime { override def toString = "Now" }
case object ReportValue extends ComplexEvaluationTime { override def toString = "Report" }
case object PageValue extends ComplexEvaluationTime { override def toString = "Page" }
case object ColumnValue extends ComplexEvaluationTime { override def toString = "Column" }
case object GroupValue2 extends ComplexEvaluationTime { override def toString = "Group" }
case object BandValue2 extends ComplexEvaluationTime { override def toString = "Band" }
case object Auto extends ComplexEvaluationTime { override def toString = "Auto" }
case object MasterValue extends ComplexEvaluationTime { override def toString = "Master" }


case class GenericElement(reportElement: com.iofficecorp.jasperserver.pumped.report.ReportElement,
  genericElementType: com.iofficecorp.jasperserver.pumped.report.GenericElementType,
  genericElementParameter: Seq[com.iofficecorp.jasperserver.pumped.report.GenericElementParameter] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) extends BandOption with ElementGroupOption with CellContentsOption with FrameOption {
  lazy val attr_evaluationTime = attributes("@evaluationTime").as[ComplexEvaluationTime]
  lazy val attr_evaluationGroup = attributes.get("@evaluationGroup") map { _.as[String] }
}

      


case class GenericElementType(attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_namespace = attributes("@namespace").as[String]
  lazy val attr_name = attributes("@name").as[String]
}

      


case class ValueExpression2(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_class = attributes("@class").as[String]
}

      


case class GenericElementParameter(valueExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueExpression2] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_skipWhenNull = attributes("@skipWhenNull").as[Boolean]
}

      


case class MultiAxisData(multiAxisDataset: com.iofficecorp.jasperserver.pumped.report.MultiAxisDataset,
  dataAxis: Seq[com.iofficecorp.jasperserver.pumped.report.DataAxis] = Nil,
  multiAxisMeasure: Seq[com.iofficecorp.jasperserver.pumped.report.MultiAxisMeasure] = Nil)
      


case class MultiAxisDataset(dataset: Option[com.iofficecorp.jasperserver.pumped.report.Dataset] = None)
      

trait AxisType

object AxisType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): AxisType = value match {
    case "Rows" => Rows
    case "Columns" => Columns

  }
}

case object Rows extends AxisType { override def toString = "Rows" }
case object Columns extends AxisType { override def toString = "Columns" }


case class DataAxis(axisLevel: Seq[com.iofficecorp.jasperserver.pumped.report.AxisLevel] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_axis = attributes("@axis").as[AxisType]
}

      


case class LabelExpression2(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class AxisLevel(labelExpression: com.iofficecorp.jasperserver.pumped.report.LabelExpression2,
  axisLevelBucket: com.iofficecorp.jasperserver.pumped.report.AxisLevelBucket,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
}

      

trait OrderType2

object OrderType2 {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): OrderType2 = value match {
    case "Ascending" => AscendingValue2
    case "Descending" => DescendingValue2
    case "None" => NoneTypeValue23

  }
}

case object AscendingValue2 extends OrderType2 { override def toString = "Ascending" }
case object DescendingValue2 extends OrderType2 { override def toString = "Descending" }
case object NoneTypeValue23 extends OrderType2 { override def toString = "None" }


case class AxisLevelBucket(bucketExpression: Option[com.iofficecorp.jasperserver.pumped.report.BucketExpression] = None,
  comparatorExpression: Option[com.iofficecorp.jasperserver.pumped.report.ComparatorExpression] = None,
  bucketProperty: Seq[com.iofficecorp.jasperserver.pumped.report.BucketProperty] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_class = attributes("@class").as[String]
  lazy val attr_order = attributes("@order").as[OrderType2]
}

      


case class BucketProperty(mixed: Seq[scalaxb.DataRecord[Any]] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
}

      


case class LabelExpression3(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class ValueExpression3(mixed: Seq[scalaxb.DataRecord[Any]] = Nil)
      


case class MultiAxisMeasure(labelExpression: com.iofficecorp.jasperserver.pumped.report.LabelExpression3,
  valueExpression: Option[com.iofficecorp.jasperserver.pumped.report.ValueExpression3] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_name = attributes("@name").as[String]
  lazy val attr_class = attributes.get("@class") map { _.as[String] }
  lazy val attr_calculation = attributes("@calculation").as[AggregationCalculationType]
  lazy val attr_incrementerFactoryClass = attributes.get("@incrementerFactoryClass") map { _.as[String] }
}

      

trait ContentsPosition

object ContentsPosition {
  def fromString(value: String, scope: scala.xml.NamespaceBinding): ContentsPosition = value match {
    case "Left" => LeftTypeValue13
    case "Center" => CenterValue8
    case "Right" => RightTypeValue13
    case "Stretch" => StretchValue4

  }
}

case object LeftTypeValue13 extends ContentsPosition { override def toString = "Left" }
case object CenterValue8 extends ContentsPosition { override def toString = "Center" }
case object RightTypeValue13 extends ContentsPosition { override def toString = "Right" }
case object StretchValue4 extends ContentsPosition { override def toString = "Stretch" }


case class CrosstabColumnCell(cellContents: com.iofficecorp.jasperserver.pumped.report.CellContents,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map()) {
  lazy val attr_height = attributes("@height").as[String]
  lazy val attr_contentsPosition = attributes("@contentsPosition").as[ContentsPosition]
}

      

